-- 公共前置语句：创建测试表并插入数据
CREATE TABLE TEST1(I INT);
INSERT INTO TEST1 VALUES(1);
INSERT INTO TEST1 VALUES(2);
CREATE TABLE TEST2(J INT);
INSERT INTO TEST2 VALUES(5);
INSERT INTO TEST2 VALUES(6);
INSERT INTO TEST2 VALUES(7);
CREATE TABLE MYEMPLOYEES(
    EMPLOYEEID  SMALLINT,
    FIRST_NAME  VARCHAR2(30) NOT NULL,
    LAST_NAME   VARCHAR2(40) NOT NULL,
    TITLE       VARCHAR2(50) NOT NULL,
    DEPTID      SMALLINT NOT NULL,
    MANAGERID   INT NULL
);
INSERT INTO MYEMPLOYEES VALUES (1, 'KEN', 'SANCHEZ', 'CHIEF EXECUTIVE OFFICER', 16, NULL);
INSERT INTO MYEMPLOYEES VALUES (273, 'BRIAN', 'WELCKER', 'VICE PRESIDENT OF SALES', 3, 1);
INSERT INTO MYEMPLOYEES VALUES (274, 'STEPHEN', 'JIANG', 'NORTH AMERICAN SALES MANAGER', 3, 273);
INSERT INTO MYEMPLOYEES VALUES (275, 'MICHAEL', 'BLYTHE', 'SALES REPRESENTATIVE', 3, 274);
INSERT INTO MYEMPLOYEES VALUES (276, 'LINDA', 'MITCHELL', 'SALES REPRESENTATIVE', 3, 274);
INSERT INTO MYEMPLOYEES VALUES (285, 'SYED', 'ABBAS', 'PACIFIC SALES MANAGER', 3, 273);
INSERT INTO MYEMPLOYEES VALUES (286, 'LYNN', 'TSOFLIAS', 'SALES REPRESENTATIVE', 3, 285);
INSERT INTO MYEMPLOYEES VALUES (16, 'DAVID', 'BRADLEY', 'MARKETING MANAGER', 4, 273);
INSERT INTO MYEMPLOYEES VALUES (23, 'MARY', 'GIBSON', 'MARKETING SPECIALIST', 4, 16);
-- 测试用例1：简单的非递归WITH CTE
WITH CTE1(K) AS (SELECT I FROM TEST1 WHERE I > 1)
SELECT K FROM CTE1;
-- 测试用例2：多个非递归WITH CTE
WITH CTE1(K) AS (SELECT I FROM TEST1 WHERE I > 1),
     CTE2(G) AS (SELECT J FROM TEST2 WHERE J > 5)
SELECT K, G FROM CTE1, CTE2;
-- 测试用例3：非递归WITH CTE用于INSERT
INSERT INTO TEST2 WITH CTE1 AS (SELECT * FROM TEST1) SELECT * FROM CTE1;
SELECT * FROM TEST2;
-- 测试用例4：非递归WITH CTE用于UPDATE
WITH CTE1 AS (SELECT * FROM TEST1 WHERE I = 1)
UPDATE TEST2 SET J = (SELECT I FROM CTE1) WHERE J = 5;
SELECT * FROM TEST2;
-- 测试用例5：非递归WITH CTE用于DELETE
WITH CTE1 AS (SELECT * FROM TEST1 WHERE I = 2)
DELETE FROM TEST2 WHERE J IN (SELECT I FROM CTE1);
SELECT * FROM TEST2;
-- 测试用例6：简单的递归WITH CTE
WITH DIRECTREPORTS(MANAGERID, EMPLOYEEID, TITLE, DEPTID) AS (
    SELECT MANAGERID, EMPLOYEEID, TITLE, DEPTID  
    FROM MYEMPLOYEES 
    WHERE MANAGERID IS NULL   -- 定位点成员
    UNION ALL
    SELECT E.MANAGERID, E.EMPLOYEEID, E.TITLE, E.DEPTID  
    FROM MYEMPLOYEES E
    INNER JOIN DIRECTREPORTS D ON E.MANAGERID = D.EMPLOYEEID  -- 递归成员
)
SELECT MANAGERID, EMPLOYEEID, TITLE FROM DIRECTREPORTS;
-- 测试用例7：递归WITH CTE用于分层数据查询
WITH DIRECTREPORTS(MANAGERID, EMPLOYEEID, TITLE, DEPTID) AS (
    SELECT MANAGERID, EMPLOYEEID, TITLE, DEPTID  
    FROM MYEMPLOYEES 
    WHERE MANAGERID = 273   -- 定位点成员
    UNION ALL
    SELECT E.MANAGERID, E.EMPLOYEEID, E.TITLE, E.DEPTID  
    FROM MYEMPLOYEES E
    INNER JOIN DIRECTREPORTS D ON E.MANAGERID = D.EMPLOYEEID  -- 递归成员
)
SELECT MANAGERID, EMPLOYEEID, TITLE FROM DIRECTREPORTS;
-- 测试用例8：递归WITH CTE用于计算层级深度
WITH DIRECTREPORTS(MANAGERID, EMPLOYEEID, TITLE, DEPTID, LEVEL) AS (
    SELECT MANAGERID, EMPLOYEEID, TITLE, DEPTID, 1 AS LEVEL
    FROM MYEMPLOYEES 
    WHERE MANAGERID IS NULL   -- 定位点成员
    UNION ALL
    SELECT E.MANAGERID, E.EMPLOYEEID, E.TITLE, E.DEPTID, D.LEVEL + 1
    FROM MYEMPLOYEES E
    INNER JOIN DIRECTREPORTS D ON E.MANAGERID = D.EMPLOYEEID  -- 递归成员
)
SELECT MANAGERID, EMPLOYEEID, TITLE, LEVEL FROM DIRECTREPORTS;
-- 测试用例9：递归WITH CTE用于生成路径
WITH DIRECTREPORTS(MANAGERID, EMPLOYEEID, TITLE, DEPTID, PATH) AS (
    SELECT MANAGERID, EMPLOYEEID, TITLE, DEPTID, CAST(EMPLOYEEID AS VARCHAR(100)) AS PATH
    FROM MYEMPLOYEES 
    WHERE MANAGERID IS NULL   -- 定位点成员
    UNION ALL
    SELECT E.MANAGERID, E.EMPLOYEEID, E.TITLE, E.DEPTID, CAST(D.PATH || '/' || E.EMPLOYEEID AS VARCHAR(100))
    FROM MYEMPLOYEES E
    INNER JOIN DIRECTREPORTS D ON E.MANAGERID = D.EMPLOYEEID  -- 递归成员
)
SELECT MANAGERID, EMPLOYEEID, TITLE, PATH FROM DIRECTREPORTS;
-- 测试用例10：递归WITH CTE用于生成树形结构
WITH DIRECTREPORTS(MANAGERID, EMPLOYEEID, TITLE, DEPTID, LEVEL, PATH) AS (
    SELECT MANAGERID, EMPLOYEEID, TITLE, DEPTID, 1 AS LEVEL, CAST(EMPLOYEEID AS VARCHAR(100)) AS PATH
    FROM MYEMPLOYEES 
    WHERE MANAGERID IS NULL   -- 定位点成员
    UNION ALL
    SELECT E.MANAGERID, E.EMPLOYEEID, E.TITLE, E.DEPTID, D.LEVEL + 1, CAST(D.PATH || '/' || E.EMPLOYEEID AS VARCHAR(100))
    FROM MYEMPLOYEES E
    INNER JOIN DIRECTREPORTS D ON E.MANAGERID = D.EMPLOYEEID  -- 递归成员
)
SELECT MANAGERID, EMPLOYEEID, TITLE, LEVEL, PATH FROM DIRECTREPORTS ORDER BY PATH;
-- 测试用例11：非递归WITH CTE用于视图创建
CREATE VIEW TEST_VIEW AS
WITH CTE1(K) AS (SELECT I FROM TEST1 WHERE I > 1)
SELECT K FROM CTE1;
SELECT * FROM TEST_VIEW;
-- 测试用例12：递归WITH CTE用于视图创建
CREATE VIEW RECURSIVE_VIEW AS
WITH DIRECTREPORTS(MANAGERID, EMPLOYEEID, TITLE, DEPTID) AS (
    SELECT MANAGERID, EMPLOYEEID, TITLE, DEPTID  
    FROM MYEMPLOYEES 
    WHERE MANAGERID IS NULL   -- 定位点成员
    UNION ALL
    SELECT E.MANAGERID, E.EMPLOYEEID, E.TITLE, E.DEPTID  
    FROM MYEMPLOYEES E
    INNER JOIN DIRECTREPORTS D ON E.MANAGERID = D.EMPLOYEEID  -- 递归成员
)
SELECT MANAGERID, EMPLOYEEID, TITLE FROM DIRECTREPORTS;
SELECT * FROM RECURSIVE_VIEW;
-- 测试用例13：非递归WITH CTE用于复杂查询
WITH CTE1(K) AS (SELECT I FROM TEST1 WHERE I > 1),
     CTE2(G) AS (SELECT J FROM TEST2 WHERE J > 5)
SELECT K, G FROM CTE1 CROSS JOIN CTE2;
-- 测试用例14：递归WITH CTE用于复杂查询
WITH DIRECTREPORTS(MANAGERID, EMPLOYEEID, TITLE, DEPTID, LEVEL) AS (
    SELECT MANAGERID, EMPLOYEEID, TITLE, DEPTID, 1 AS LEVEL
    FROM MYEMPLOYEES 
    WHERE MANAGERID = 273   -- 定位点成员
    UNION ALL
    SELECT E.MANAGERID, E.EMPLOYEEID, E.TITLE, E.DEPTID, D.LEVEL + 1
    FROM MYEMPLOYEES E
    INNER JOIN DIRECTREPORTS D ON E.MANAGERID = D.EMPLOYEEID  -- 递归成员
)
SELECT MANAGERID, EMPLOYEEID, TITLE, LEVEL FROM DIRECTREPORTS WHERE LEVEL > 1;
-- 测试用例15：递归WITH CTE用于生成层级路径
WITH DIRECTREPORTS(MANAGERID, EMPLOYEEID, TITLE, DEPTID, PATH) AS (
    SELECT MANAGERID, EMPLOYEEID, TITLE, DEPTID, CAST(EMPLOYEEID AS VARCHAR(100)) AS PATH
    FROM MYEMPLOYEES 
    WHERE MANAGERID = 273   -- 定位点成员
    UNION ALL
    SELECT E.MANAGERID, E.EMPLOYEEID, E.TITLE, E.DEPTID, CAST(D.PATH || '/' || E.EMPLOYEEID AS VARCHAR(100))
    FROM MYEMPLOYEES E
    INNER JOIN DIRECTREPORTS D ON E.MANAGERID = D.EMPLOYEEID  -- 递归成员
)
SELECT MANAGERID, EMPLOYEEID, TITLE, PATH FROM DIRECTREPORTS