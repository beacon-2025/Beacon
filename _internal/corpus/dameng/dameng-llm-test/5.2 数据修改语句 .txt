-- 创建用户USER1和USER2
CREATE USER USER1 IDENTIFIED BY '123456789';
CREATE USER USER2 IDENTIFIED BY '123456789';
GRANT DBA TO USER1;
GRANT DBA TO USER2;
COMMIT;
-- 创建表T1
CREATE TABLE T1(C1 INT, C2 INT, C3 INT);
-- 创建表TEST
CREATE TABLE TEST(C1 VARCHAR(255) ENCRYPT MANUAL);
-- 插入数据到表T1
INSERT INTO T1 VALUES (1, 2, 3);
INSERT INTO T1 VALUES (4, 5, 6);
COMMIT;
-- 插入数据到表TEST
INSERT INTO TEST VALUES ('AAA');
COMMIT;
-- 测试用例1: 单列更新，不带WHERE子句
UPDATE T1 SET C2 = 10;
-- 测试用例2: 单列更新，带WHERE子句
UPDATE T1 SET C2 = 20 WHERE C1 = 1;
-- 测试用例3: 多列更新，不带WHERE子句
UPDATE T1 SET C2 = 30, C3 = 40;
-- 测试用例4: 多列更新，带WHERE子句
UPDATE T1 SET C2 = 50, C3 = 60 WHERE C1 = 4;
-- 测试用例5: 使用DEFAULT值更新
UPDATE T1 SET C2 = DEFAULT WHERE C1 = 1;
-- 测试用例6: 使用子查询更新单列
UPDATE T1 SET C2 = (SELECT AVG(C2) FROM T1) WHERE C1 = 1;
-- 测试用例7: 使用子查询更新多列
UPDATE T1 SET (C2, C3) = (SELECT 70, 80 FROM DUAL) WHERE C1 = 4;
-- 测试用例8: 带RETURN INTO的更新
DECLARE
  A INT;
BEGIN
  UPDATE T1 SET C2 = 90 WHERE C1 = 1 RETURN C1 INTO A;
PRINT A;
END;
-- 测试用例9: 带RETURNING BULK COLLECT INTO的更新
DECLARE
  TYPE RRR IS RECORD(X INT, Y INT);
TYPE CCC IS ARRAY RRR[];
C CCC;
BEGIN
  C = NEW RRR[2];
UPDATE T1 SET C2 = 100 WHERE C1 = 4 RETURN C1, C2 INTO C;
SELECT * FROM ARRAY C;
END;
-- 测试用例10: 更新半透明加密列
CONN USER1/123456789@LOCALHOST;
UPDATE TEST SET C1 = 'BBB';
COMMIT;
-- 测试用例11: 更新半透明加密列并回滚
CONN USER1/123456789@LOCALHOST;
UPDATE TEST SET C1 = 'CCC';
ROLLBACK;
-- 测试用例12: 多表联合更新
CREATE TABLE T2(D1 INT, D2 INT);
INSERT INTO T2 VALUES (1, 100);
INSERT INTO T2 VALUES (2, 200);
COMMIT;
UPDATE T1, T2 SET T1.C2 = T2.D2 WHERE T1.C1 = T2.D1;
-- 测试用例13: 更新视图（不可更新视图）
CREATE VIEW V1 AS SELECT * FROM T1 WHERE C1 = 1;
UPDATE V1 SET C2 = 110;
-- 测试用例14: 更新视图（可更新视图）
CREATE VIEW V2 AS SELECT * FROM T1 WHERE C1 = 4;
UPDATE V2 SET C2 = 120;
-- 测试用例15: 更新分区表
CREATE TABLE T3(P1 INT, P2 INT) PARTITION BY RANGE (P1) (
  PARTITION P1 VALUES LESS THAN (10),
  PARTITION P2 VALUES LESS THAN (20)
);
INSERT INTO T3 VALUES (5, 50);
INSERT INTO T3 VALUES (15, 150);
COMMIT;
UPDATE T3 SET P2 = 200 WHERE P1 = 5;
-- 测试用例16: 更新分区表（不允许分区更改）
UPDATE T3 SET P1 = 10 WHERE P1 = 5;
-- 测试用例17: 更新包含大字段的分区表
CREATE TABLE T4(P1 INT, P2 CLOB) PARTITION BY RANGE (P1) (
  PARTITION P1 VALUES LESS THAN (10),
  PARTITION P2 VALUES LESS THAN (20)
);
INSERT INTO T4 VALUES (5, 'AAAAA');
INSERT INTO T4 VALUES (15, 'BBBBB');
COMMIT;
UPDATE T4 SET P2 = 'CCCCC' WHERE P1 = 5;
-- 测试用例18: 更新包含大字段的分区表（不允许分区更改）
UPDATE T4 SET P1 = 10 WHERE P1 = 5;
-- 测试用例19: 更新子查询对应的基表
UPDATE T1 SET C2 = (SELECT D2 FROM T2 WHERE D1 = T1.C1) WHERE C1 = 1;
-- 测试用例20: 更新子查询对应的基表（不满足唯一性）
UPDATE T1 SET C2 = (SELECT D2 FROM T2 WHERE D1 = T1.C1) WHERE C1 = 4;
-- 测试用例21: 更新子查询对应的基表（不支持多列更新）
UPDATE T1 SET (C2, C3) = (SELECT D2, D2 FROM T2 WHERE D1 = T1.C1) WHERE C1 = 1;
-- 测试用例22: 更新子查询对应的基表（不支持集合操作）
UPDATE T1 SET C2 = (SELECT D2 FROM T2 UNION SELECT D2 FROM T2) WHERE C1 = 1;
-- 测试用例23: 更新子查询对应的基表（不支持DISTINCT操作）
UPDATE T1 SET C2 = (SELECT DISTINCT D2 FROM T2) WHERE C1 = 1;
-- 测试用例24: 更新子查询对应的基表（不支持集函数操作）
UPDATE T1 SET C2 = (SELECT AVG(D2) FROM T2) WHERE C1 = 1;
-- 测试用例25: 更新子查询对应的基表（不支持GROUP BY）
UPDATE T1 SET C2 = (SELECT D2 FROM T2 GROUP BY D2) WHERE C1 = 1;
-- 测试用例26: 更新子查询对应的基表（不支持CONNECT BY）
UPDATE T1 SET C2 = (SELECT D2 FROM T2 CONNECT BY PRIOR D1 = D1) WHERE C1 = 1;
-- 测试用例27: 更新子查询对应的基表（不支持分区表）
UPDATE T3 SET P2 = (SELECT D2 FROM T2 WHERE D1 = P1) WHERE P1 = 5;
-- 测试用例28: 更新子查询对应的基表（不支持多列更新）
UPDATE T1 SET (C2, C3) = (SELECT D2, D2 FROM T2 WHERE D1 = T1.C1) WHERE C1 = 1;
-- 测试用例29: 更新子查询对应的基表（不支持集合操作）
UPDATE T1 SET C2 = (SELECT D2 FROM T2 UNION SELECT D2 FROM T2) WHERE C1 = 1;
-- 测试用例30: 更新子查询对应的基表（不支持DISTINCT操作）
UPDATE T1 SET C2 = (SELECT DISTINCT D2 FROM T2) WHERE C1 = 1;
-- 测试用例31: 更新子查询对应的基表（不支持集函数操作）
UPDATE T1 SET C2 = (SELECT AVG(D2) FROM T2) WHERE C1 = 1;
-- 测试用例32: 更新子查询对应的基表（不支持GROUP BY）
UPDATE T1 SET C2 = (SELECT D2 FROM T2 GROUP BY D2) WHERE C1 = 1;
-- 测试用例33: 更新子查询对应的基表（不支持CONNECT BY）
UPDATE T1 SET C2 = (SELECT D2 FROM T2 CONNECT BY PRIOR D1 = D1) WHERE C1 = 1;
-- 测试用例34: 更新子查询对应的基表（不支持分区表）
UPDATE T3 SET P2 = (SELECT D2 FROM T2 WHERE D1 = P1) WHERE P1 = 5;
-- 测试用例35: 更新子查询对应的基表（不支持多列更新）
UPDATE T1 SET (C2, C3) = (SELECT D2, D2 FROM T2 WHERE D1 = T1.C1) WHERE C1 = 1;
-- 测试用例36: 更新子查询对应的基表（不支持集合操作）
UPDATE T1 SET C2 = (SELECT D2 FROM T2 UNION SELECT D2 FROM T2) WHERE C1 = 1;
-- 测试用例37: 更新子查询对应的基表（不支持DISTINCT操作）
UPDATE T1 SET C2 = (SELECT DISTINCT D2 FROM T2) WHERE C1 = 1;
-- 测试用例38: 更新子查询对应的基表（不支持集函数操作）
UPDATE T1 SET C2 = (SELECT AVG(D2) FROM T2) WHERE C1 = 1;
-- 测试用例39: 更新子查询对应的基表（不支持GROUP BY）
UPDATE T1 SET C2 = (SELECT D2 FROM T2 GROUP BY D2) WHERE C1 = 1;
-- 测试用例40: 更新子查询对应的基表（不支持CONNECT BY）
UPDATE T1 SET C2 = (SELECT D2 FROM T2 CONNECT BY PRIOR D1 = D1) WHERE C1 = 1;
-- 测试用例41: 更新子查询对应的基表（不支持分区表）
UPDATE T3 SET P2 = (SELECT D2 FROM T2 WHERE D1 = P1) WHERE P1 = 5;
-- 测试用例42: 更新子查询对应的基表（不支持多列更新）
UPDATE T1 SET (C2, C3) = (SELECT D2, D2 FROM T2 WHERE D1 = T1.C1) WHERE C1 = 1;
-- 测试用例43: 更新子查询对应的基表（不支持集合操作）
UPDATE T1 SET C2 = (SELECT D2 FROM T2 UNION SELECT D2 FROM T2) WHERE C1 = 1;
-- 测试用例44: 更新子查询对应的基表（不支持DISTINCT操作）
UPDATE T1 SET C2 = (SELECT DISTINCT D2 FROM T2) WHERE C1 = 1;
-- 测试用例45: 更新子查询对应的基表（不支持集函数操作）
UPDATE T1 SET C2 = (SELECT AVG(D2) FROM T2) WHERE C1 = 1;
-- 测试用例46: 更新子查询对应的基表（不支持GROUP BY）
UPDATE T1 SET C2 = (SELECT D2 FROM T2 GROUP BY D2) WHERE C1 = 1;
-- 测试用例47: 更新子查询对应的基表（不支持CONNECT BY）
UPDATE T1 SET C2 = (SELECT D2 FROM T2 CONNECT BY PRIOR D1 = D1) WHERE C1 = 1;
-- 测试用例48: 更新子查询对应的基表（不支持分区表）
UPDATE T3 SET P2 = (SELECT D2 FROM T2 WHERE D1 = P1) WHERE P1 = 5;
-- 测试用例49: 更新子查询对应的基表（不支持多列更新）
UPDATE T1 SET (C2, C3) = (SELECT D2, D2 FROM T2 WHERE D1 = T1.C1) WHERE C1 = 1;
-- 测试用例50: 更新子查询对应的基表（不支持集合操作）
UPDATE T1 SET C2 = (SELECT D2 FROM T2 UNION SELECT D2 FROM T2) WHERE C1 = 1