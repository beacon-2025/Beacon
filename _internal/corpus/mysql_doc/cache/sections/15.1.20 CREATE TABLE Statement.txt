15.1.20 CREATE TABLE Statement
CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name
    (create_definition,...)
    [table_options]
    [partition_options]
CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name
    [(create_definition,...)]
    [table_options]
    [partition_options]
    [IGNORE | REPLACE]
    [AS] query_expression
CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name
    { LIKE old_tbl_name | (LIKE old_tbl_name) }
create_definition: {
    col_name column_definition
  | {INDEX | KEY} [index_name] [index_type] (key_part,...)
      [index_option] ...
  | {FULLTEXT | SPATIAL} [INDEX | KEY] [index_name] (key_part,...)
      [index_option] ...
  | [CONSTRAINT [symbol]] PRIMARY KEY
      [index_type] (key_part,...)
      [index_option] ...
  | [CONSTRAINT [symbol]] UNIQUE [INDEX | KEY]
      [index_name] [index_type] (key_part,...)
      [index_option] ...
  | [CONSTRAINT [symbol]] FOREIGN KEY
      [index_name] (col_name,...)
      reference_definition
  | check_constraint_definition
}
column_definition: {
    data_type [NOT NULL | NULL] [DEFAULT {literal | (expr)} ]
      [VISIBLE | INVISIBLE]
      [AUTO_INCREMENT] [UNIQUE [KEY]] [[PRIMARY] KEY]
      [COMMENT 'string']
      [COLLATE collation_name]
      [COLUMN_FORMAT {FIXED | DYNAMIC | DEFAULT}]
      [ENGINE_ATTRIBUTE [=] 'string']
      [SECONDARY_ENGINE_ATTRIBUTE [=] 'string']
      [STORAGE {DISK | MEMORY}]
      [reference_definition]
      [check_constraint_definition]
  | data_type
      [COLLATE collation_name]
      [GENERATED ALWAYS] AS (expr)
      [VIRTUAL | STORED] [NOT NULL | NULL]
      [VISIBLE | INVISIBLE]
      [UNIQUE [KEY]] [[PRIMARY] KEY]
      [COMMENT 'string']
      [reference_definition]
      [check_constraint_definition]
}
data_type:
    (see Chapter 13, Data Types)
key_part: {col_name [(length)] | (expr)} [ASC | DESC]
index_type:
    USING {BTREE | HASH}
index_option: {
    KEY_BLOCK_SIZE [=] value
  | index_type
  | WITH PARSER parser_name
  | COMMENT 'string'
  | {VISIBLE | INVISIBLE}
  |ENGINE_ATTRIBUTE [=] 'string'
  |SECONDARY_ENGINE_ATTRIBUTE [=] 'string'
}
check_constraint_definition:
    [CONSTRAINT [symbol]] CHECK (expr) [[NOT] ENFORCED]
reference_definition:
    REFERENCES tbl_name (key_part,...)
      [MATCH FULL | MATCH PARTIAL | MATCH SIMPLE]
      [ON DELETE reference_option]
      [ON UPDATE reference_option]
reference_option:
    RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT
table_options:
    table_option [[,] table_option] ...
table_option: {
    AUTOEXTEND_SIZE [=] value
  | AUTO_INCREMENT [=] value
  | AVG_ROW_LENGTH [=] value
  | [DEFAULT] CHARACTER SET [=] charset_name
  | CHECKSUM [=] {0 | 1}
  | [DEFAULT] COLLATE [=] collation_name
  | COMMENT [=] 'string'
  | COMPRESSION [=] {'ZLIB' | 'LZ4' | 'NONE'}
  | CONNECTION [=] 'connect_string'
  | {DATA | INDEX} DIRECTORY [=] 'absolute path to directory'
  | DELAY_KEY_WRITE [=] {0 | 1}
  | ENCRYPTION [=] {'Y' | 'N'}
  | ENGINE [=] engine_name
  | ENGINE_ATTRIBUTE [=] 'string'
  | INSERT_METHOD [=] { NO | FIRST | LAST }
  | KEY_BLOCK_SIZE [=] value
  | MAX_ROWS [=] value
  | MIN_ROWS [=] value
  | PACK_KEYS [=] {0 | 1 | DEFAULT}
  | PASSWORD [=] 'string'
  | ROW_FORMAT [=] {DEFAULT | DYNAMIC | FIXED | COMPRESSED | REDUNDANT | COMPACT}
  | START TRANSACTION 
  | SECONDARY_ENGINE_ATTRIBUTE [=] 'string'
  | STATS_AUTO_RECALC [=] {DEFAULT | 0 | 1}
  | STATS_PERSISTENT [=] {DEFAULT | 0 | 1}
  | STATS_SAMPLE_PAGES [=] value
  | tablespace_option
  | UNION [=] (tbl_name[,tbl_name]...)
}
partition_options:
    PARTITION BY
        { [LINEAR] HASH(expr)
        | [LINEAR] KEY [ALGORITHM={1 | 2}] (column_list)
        | RANGE{(expr) | COLUMNS(column_list)}
        | LIST{(expr) | COLUMNS(column_list)} }
    [PARTITIONS num]
    [SUBPARTITION BY
        { [LINEAR] HASH(expr)
        | [LINEAR] KEY [ALGORITHM={1 | 2}] (column_list) }
      [SUBPARTITIONS num]
    ]
    [(partition_definition [, partition_definition] ...)]
partition_definition:
    PARTITION partition_name
        [VALUES
            {LESS THAN {(expr | value_list) | MAXVALUE}
            |
            IN (value_list)}]
        [[STORAGE] ENGINE [=] engine_name]
        [COMMENT [=] 'string' ]
        [DATA DIRECTORY [=] 'data_dir']
        [INDEX DIRECTORY [=] 'index_dir']
        [MAX_ROWS [=] max_number_of_rows]
        [MIN_ROWS [=] min_number_of_rows]
        [TABLESPACE [=] tablespace_name]
        [(subpartition_definition [, subpartition_definition] ...)]
subpartition_definition:
    SUBPARTITION logical_name
        [[STORAGE] ENGINE [=] engine_name]
        [COMMENT [=] 'string' ]
        [DATA DIRECTORY [=] 'data_dir']
        [INDEX DIRECTORY [=] 'index_dir']
        [MAX_ROWS [=] max_number_of_rows]
        [MIN_ROWS [=] min_number_of_rows]
        [TABLESPACE [=] tablespace_name]
tablespace_option:
    TABLESPACE tablespace_name [STORAGE DISK]
  | [TABLESPACE tablespace_name] STORAGE MEMORY
query_expression:
    SELECT ...   (Some valid select or union statement)
CREATE TABLE creates a table with the given name. You must have the CREATE privilege for the
table.
By default, tables are created in the default database, using the InnoDB storage engine. An error
occurs if the table exists, if there is no default database, or if the database does not exist.
MySQL has no limit on the number of tables. The underlying file system may have a limit on the
number of files that represent tables. Individual storage engines may impose engine-specific
constraints. InnoDB permits up to 4 billion tables.
For information about the physical representation of a table, see Section 15.1.20.1, “Files Created by
CREATE TABLE”.
There are several aspects to the CREATE TABLE statement, described under the following topics in
this section:
• Table Name
• Temporary Tables
• Table Cloning and Copying
• Column Data Types and Attributes
• Indexes, Foreign Keys, and CHECK Constraints
• Table Options
• Table Partitioning
Table Name
• tbl_name
The table name can be specified as db_name.tbl_name to create the table in a specific database.
This works regardless of whether there is a default database, assuming that the database exists.
If you use quoted identifiers, quote the database and table names separately. For example, write
`mydb`.`mytbl`, not `mydb.mytbl`.
Rules for permissible table names are given in Section 11.2, “Schema Object Names”.
• IF NOT EXISTS
Prevents an error from occurring if the table exists. However, there is no verification that the existing
table has a structure identical to that indicated by the CREATE TABLE statement.
Temporary Tables
You can use the TEMPORARY keyword when creating a table. A TEMPORARY table is visible only within
the current session, and is dropped automatically when the session is closed. For more information,
see Section 15.1.20.2, “CREATE TEMPORARY TABLE Statement”.
Table Cloning and Copying
• LIKE
Use CREATE TABLE ... LIKE to create an empty table based on the definition of another table,
including any column attributes and indexes defined in the original table:
CREATE TABLE new_tbl LIKE orig_tbl;
For more information, see Section 15.1.20.3, “CREATE TABLE ... LIKE Statement”.
• [AS] query_expression
To create one table from another, add a SELECT statement at the end of the CREATE TABLE
statement:
CREATE TABLE new_tbl AS SELECT * FROM orig_tbl;
For more information, see Section 15.1.20.4, “CREATE TABLE ... SELECT Statement”.
• IGNORE | REPLACE
The IGNORE and REPLACE options indicate how to handle rows that duplicate unique key values
when copying a table using a SELECT statement.
For more information, see Section 15.1.20.4, “CREATE TABLE ... SELECT Statement”.
Column Data Types and Attributes
There is a hard limit of 4096 columns per table, but the effective maximum may be less for a given
table and depends on the factors discussed in Section 10.4.7, “Limits on Table Column Count and Row
Size”.
• data_type
data_type represents the data type in a column definition. For a full description of the syntax
available for specifying column data types, as well as information about the properties of each type,
see Chapter 13, Data Types.
• AUTO_INCREMENT applies only to integer types.
• Character data types (CHAR, VARCHAR, the TEXT types, ENUM, SET, and any synonyms) can
include CHARACTER SET to specify the character set for the column. CHARSET is a synonym for
CHARACTER SET. A collation for the character set can be specified with the COLLATE attribute,
along with any other attributes. For details, see Chapter 12, Character Sets, Collations, Unicode.
Example:
CREATE TABLE t (c CHAR(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin);
MySQL 9.1 interprets length specifications in character column definitions in characters. Lengths
for BINARY and VARBINARY are in bytes.
• For CHAR, VARCHAR, BINARY, and VARBINARY columns, indexes can be created that use only the
leading part of column values, using col_name(length) syntax to specify an index prefix length.
BLOB and TEXT columns also can be indexed, but a prefix length must be given. Prefix lengths are
given in characters for nonbinary string types and in bytes for binary string types. That is, index
entries consist of the first length characters of each column value for CHAR, VARCHAR, and TEXT
columns, and the first length bytes of each column value for BINARY, VARBINARY, and BLOB
columns. Indexing only a prefix of column values like this can make the index file much smaller.
For additional information about index prefixes, see Section 15.1.15, “CREATE INDEX Statement”.
Only the InnoDB and MyISAM storage engines support indexing on BLOB and TEXT columns. For
example:
CREATE TABLE test (blob_col BLOB, INDEX(blob_col(10)));
If a specified index prefix exceeds the maximum column data type size, CREATE TABLE handles
the index as follows:
• For a nonunique index, either an error occurs (if strict SQL mode is enabled), or the index length
is reduced to lie within the maximum column data type size and a warning is produced (if strict
SQL mode is not enabled).
• For a unique index, an error occurs regardless of SQL mode because reducing the index
length might enable insertion of nonunique entries that do not meet the specified uniqueness
requirement.
• JSON columns cannot be indexed. You can work around this restriction by creating an index on a
generated column that extracts a scalar value from the JSON column. See Indexing a Generated
Column to Provide a JSON Column Index, for a detailed example.
• NOT NULL | NULL
If neither NULL nor NOT NULL is specified, the column is treated as though NULL had been
specified.
In MySQL 9.1, only the InnoDB, MyISAM, and MEMORY storage engines support indexes on columns
that can have NULL values. In other cases, you must declare indexed columns as NOT NULL or an
error results.
• DEFAULT
Specifies a default value for a column. For more information about default value handling, including
the case that a column definition includes no explicit DEFAULT value, see Section 13.6, “Data Type
Default Values”.
If the NO_ZERO_DATE or NO_ZERO_IN_DATE SQL mode is enabled and a date-valued default is
not correct according to that mode, CREATE TABLE produces a warning if strict SQL mode is not
enabled and an error if strict mode is enabled. For example, with NO_ZERO_IN_DATE enabled, c1
DATE DEFAULT '2010-00-00' produces a warning.
• VISIBLE, INVISIBLE
Specify column visibility. The default is VISIBLE if neither keyword is present. A table must have
at least one visible column. Attempting to make all columns invisible produces an error. For more
information, see Section 15.1.20.10, “Invisible Columns”.
• AUTO_INCREMENT
An integer column can have the additional attribute AUTO_INCREMENT. When you insert a value of
NULL (recommended) or 0 into an indexed AUTO_INCREMENT column, the column is set to the next
sequence value. Typically this is value+1, where value is the largest value for the column currently
in the table. AUTO_INCREMENT sequences begin with 1.
To retrieve an AUTO_INCREMENT value after inserting a row, use the LAST_INSERT_ID() SQL
function or the mysql_insert_id() C API function. See Section 14.15, “Information Functions”,
and mysql_insert_id().
If the NO_AUTO_VALUE_ON_ZERO SQL mode is enabled, you can store 0 in AUTO_INCREMENT
columns as 0 without generating a new sequence value. See Section 7.1.11, “Server SQL Modes”.
There can be only one AUTO_INCREMENT column per table, it must be indexed, and it cannot have a
DEFAULT value. An AUTO_INCREMENT column works properly only if it contains only positive values.
Inserting a negative number is regarded as inserting a very large positive number. This is done to
avoid precision problems when numbers “wrap” over from positive to negative and also to ensure
that you do not accidentally get an AUTO_INCREMENT column that contains 0.
For MyISAM tables, you can specify an AUTO_INCREMENT secondary column in a multiple-column
key. See Section 5.6.9, “Using AUTO_INCREMENT”.
To make MySQL compatible with some ODBC applications, you can find the AUTO_INCREMENT
value for the last inserted row with the following query:
SELECT * FROM tbl_name WHERE auto_col IS NULL
This method requires that sql_auto_is_null variable is not set to 0. See Section 7.1.8, “Server
System Variables”.
For information about InnoDB and AUTO_INCREMENT, see Section 17.6.1.6, “AUTO_INCREMENT
Handling in InnoDB”. For information about AUTO_INCREMENT and MySQL Replication, see
Section 19.5.1.1, “Replication and AUTO_INCREMENT”.
• COMMENT
A comment for a column can be specified with the COMMENT option, up to 1024 characters long. The
comment is displayed by the SHOW CREATE TABLE and SHOW FULL COLUMNS statements. It is
also shown in the COLUMN_COMMENT column of the Information Schema COLUMNS table.
• COLUMN_FORMAT
In NDB Cluster, it is also possible to specify a data storage format for individual columns of NDB
tables using COLUMN_FORMAT. Permissible column formats are FIXED, DYNAMIC, and DEFAULT.
FIXED is used to specify fixed-width storage, DYNAMIC permits the column to be variable-width,
and DEFAULT causes the column to use fixed-width or variable-width storage as determined by the
column's data type (possibly overridden by a ROW_FORMAT specifier).
For NDB tables, the default value for COLUMN_FORMAT is FIXED.
In NDB Cluster, the maximum possible offset for a column defined with COLUMN_FORMAT=FIXED
is 8188 bytes. For more information and possible workarounds, see Section 25.2.7.5, “Limits
Associated with Database Objects in NDB Cluster”.
COLUMN_FORMAT currently has no effect on columns of tables using storage engines other than NDB.
MySQL 9.1 silently ignores COLUMN_FORMAT.
• ENGINE_ATTRIBUTE and SECONDARY_ENGINE_ATTRIBUTE options are used to specify column
attributes for primary and secondary storage engines. The options are reserved for future use.
The value assigned to this option is a string literal containing a valid JSON document or an empty
string (''). Invalid JSON is rejected.
CREATE TABLE t1 (c1 INT ENGINE_ATTRIBUTE='{"key":"value"}');
ENGINE_ATTRIBUTE and SECONDARY_ENGINE_ATTRIBUTE values can be repeated without error.
In this case, the last specified value is used.
ENGINE_ATTRIBUTE and SECONDARY_ENGINE_ATTRIBUTE values are not checked by the server,
nor are they cleared when the table's storage engine is changed.
• STORAGE
For NDB tables, it is possible to specify whether the column is stored on disk or in memory by using
a STORAGE clause. STORAGE DISK causes the column to be stored on disk, and STORAGE MEMORY
causes in-memory storage to be used. The CREATE TABLE statement used must still include a
TABLESPACE clause:
mysql> CREATE TABLE t1 (
    ->     c1 INT STORAGE DISK,
    ->     c2 INT STORAGE MEMORY
    -> ) ENGINE NDB;
ERROR 1005 (HY000): Can't create table 'c.t1' (errno: 140)
mysql> CREATE TABLE t1 (
    ->     c1 INT STORAGE DISK,
    ->     c2 INT STORAGE MEMORY
    -> ) TABLESPACE ts_1 ENGINE NDB;
Query OK, 0 rows affected (1.06 sec)
For NDB tables, STORAGE DEFAULT is equivalent to STORAGE MEMORY.
The STORAGE clause has no effect on tables using storage engines other than NDB. The STORAGE
keyword is supported only in the build of mysqld that is supplied with NDB Cluster; it is not
recognized in any other version of MySQL, where any attempt to use the STORAGE keyword causes
a syntax error.
• GENERATED ALWAYS
Used to specify a generated column expression. For information about generated columns, see
Section 15.1.20.8, “CREATE TABLE and Generated Columns”.
Stored generated columns can be indexed. InnoDB supports secondary indexes on virtual
generated columns. See Section 15.1.20.9, “Secondary Indexes and Generated Columns”.
Indexes, Foreign Keys, and CHECK Constraints
Several keywords apply to creation of indexes, foreign keys, and CHECK constraints. For general
background in addition to the following descriptions, see Section 15.1.15, “CREATE INDEX
Statement”, Section 15.1.20.5, “FOREIGN KEY Constraints”, and Section 15.1.20.6, “CHECK
Constraints”.
• CONSTRAINT symbol
The CONSTRAINT symbol clause may be given to name a constraint. If the clause is not given,
or a symbol is not included following the CONSTRAINT keyword, MySQL automatically generates
a constraint name, with the exception noted below. The symbol value, if used, must be unique
per schema (database), per constraint type. A duplicate symbol results in an error. See also the
discussion about length limits of generated constraint identifiers at Section 11.2.1, “Identifier Length
Limits”.
Note
If the CONSTRAINT symbol clause is not given in a foreign key definition,
or a symbol is not included following the CONSTRAINT keyword, MySQL
automatically generates a constraint name.
The SQL standard specifies that all types of constraints (primary key, unique index, foreign key,
check) belong to the same namespace. In MySQL, each constraint type has its own namespace
per schema. Consequently, names for each type of constraint must be unique per schema, but
constraints of different types can have the same name.
• PRIMARY KEY
A unique index where all key columns must be defined as NOT NULL. If they are not explicitly
declared as NOT NULL, MySQL declares them so implicitly (and silently). A table can have only one
PRIMARY KEY. The name of a PRIMARY KEY is always PRIMARY, which thus cannot be used as the
name for any other kind of index.
If you do not have a PRIMARY KEY and an application asks for the PRIMARY KEY in your tables,
MySQL returns the first UNIQUE index that has no NULL columns as the PRIMARY KEY.
In InnoDB tables, keep the PRIMARY KEY short to minimize storage overhead for secondary
indexes. Each secondary index entry contains a copy of the primary key columns for the
corresponding row. (See Section 17.6.2.1, “Clustered and Secondary Indexes”.)
In the created table, a PRIMARY KEY is placed first, followed by all UNIQUE indexes, and then the
nonunique indexes. This helps the MySQL optimizer to prioritize which index to use and also more
quickly to detect duplicated UNIQUE keys.
A PRIMARY KEY can be a multiple-column index. However, you cannot create a multiple-column
index using the PRIMARY KEY key attribute in a column specification. Doing so only marks that
single column as primary. You must use a separate PRIMARY KEY(key_part, ...) clause.
If a table has a PRIMARY KEY or UNIQUE NOT NULL index that consists of a single column that
has an integer type, you can use _rowid to refer to the indexed column in SELECT statements, as
described in Unique Indexes.
In MySQL, the name of a PRIMARY KEY is PRIMARY. For other indexes, if you do not assign a
name, the index is assigned the same name as the first indexed column, with an optional suffix
(_2, _3, ...) to make it unique. You can see index names for a table using SHOW INDEX FROM
tbl_name. See Section 15.7.7.23, “SHOW INDEX Statement”.
• KEY | INDEX
KEY is normally a synonym for INDEX. The key attribute PRIMARY KEY can also be specified as just
KEY when given in a column definition. This was implemented for compatibility with other database
systems.
• UNIQUE
A UNIQUE index creates a constraint such that all values in the index must be distinct. An error
occurs if you try to add a new row with a key value that matches an existing row. For all engines,
a UNIQUE index permits multiple NULL values for columns that can contain NULL. If you specify a
prefix value for a column in a UNIQUE index, the column values must be unique within the prefix
length.
If a table has a PRIMARY KEY or UNIQUE NOT NULL index that consists of a single column that
has an integer type, you can use _rowid to refer to the indexed column in SELECT statements, as
described in Unique Indexes.
• FULLTEXT
A FULLTEXT index is a special type of index used for full-text searches. Only the InnoDB and
MyISAM storage engines support FULLTEXT indexes. They can be created only from CHAR,
VARCHAR, and TEXT columns. Indexing always happens over the entire column; column prefix
indexing is not supported and any prefix length is ignored if specified. See Section 14.9, “Full-
Text Search Functions”, for details of operation. A WITH PARSER clause can be specified as an
index_option value to associate a parser plugin with the index if full-text indexing and searching
operations need special handling. This clause is valid only for FULLTEXT indexes. InnoDB and
MyISAM support full-text parser plugins. See Full-Text Parser Plugins and Writing Full-Text Parser
Plugins for more information.
• SPATIAL
You can create SPATIAL indexes on spatial data types. Spatial types are supported only for InnoDB
and MyISAM tables, and indexed columns must be declared as NOT NULL. See Section 13.4,
“Spatial Data Types”.
• FOREIGN KEY
MySQL supports foreign keys, which let you cross-reference related data across tables, and
foreign key constraints, which help keep this spread-out data consistent. For definition and option
information, see reference_definition, and reference_option.
Partitioned tables employing the InnoDB storage engine do not support foreign keys. See
Section 26.6, “Restrictions and Limitations on Partitioning”, for more information.
• CHECK
The CHECK clause enables the creation of constraints to be checked for data values in table rows.
See Section 15.1.20.6, “CHECK Constraints”.
• key_part
• A key_part specification can end with ASC or DESC to specify whether index values are stored in
ascending or descending order. The default is ascending if no order specifier is given.
• Prefixes, defined by the length attribute, can be up to 767 bytes long for InnoDB tables that use
the REDUNDANT or COMPACT row format. The prefix length limit is 3072 bytes for InnoDB tables
that use the DYNAMIC or COMPRESSED row format. For MyISAM tables, the prefix length limit is
1000 bytes.
Prefix limits are measured in bytes. However, prefix lengths for index specifications in CREATE
TABLE, ALTER TABLE, and CREATE INDEX statements are interpreted as number of characters
for nonbinary string types (CHAR, VARCHAR, TEXT) and number of bytes for binary string types
(BINARY, VARBINARY, BLOB). Take this into account when specifying a prefix length for a
nonbinary string column that uses a multibyte character set.
• The expr for a key_part specification can take the form (CAST json_path AS type
ARRAY) to create a multi-valued index on a JSON column. Multi-Valued Indexes, provides detailed
information regarding creation of, usage of, and restrictions and limitations on multi-valued
indexes.
• index_type
Some storage engines permit you to specify an index type when creating an index. The syntax for
the index_type specifier is USING type_name.
Example:
CREATE TABLE lookup
  (id INT, INDEX USING BTREE (id)
) ENGINE = MEMORY;
The preferred position for USING is after the index column list. It can be given before the column
list, but support for use of the option in that position is deprecated and you should expect it to be
removed in a future MySQL release.
• index_option
index_option values specify additional options for an index.
• KEY_BLOCK_SIZE
For MyISAM tables, KEY_BLOCK_SIZE optionally specifies the size in bytes to use for index
key blocks. The value is treated as a hint; a different size could be used if necessary. A
KEY_BLOCK_SIZE value specified for an individual index definition overrides the table-level
KEY_BLOCK_SIZE value.
For information about the table-level KEY_BLOCK_SIZE attribute, see Table Options.
• WITH PARSER
The WITH PARSER option can be used only with FULLTEXT indexes. It associates a parser plugin
with the index if full-text indexing and searching operations need special handling. InnoDB and
MyISAM support full-text parser plugins. If you have a MyISAM table with an associated full-text
parser plugin, you can convert the table to InnoDB using ALTER TABLE.
• COMMENT
Index definitions can include an optional comment of up to 1024 characters.
You can set the InnoDB MERGE_THRESHOLD value for an individual index using the
index_option COMMENT clause. See Section 17.8.11, “Configuring the Merge Threshold for
Index Pages”.
• VISIBLE, INVISIBLE
Specify index visibility. Indexes are visible by default. An invisible index is not used by the
optimizer. Specification of index visibility applies to indexes other than primary keys (either explicit
or implicit). For more information, see Section 10.3.12, “Invisible Indexes”.
• ENGINE_ATTRIBUTE and SECONDARY_ENGINE_ATTRIBUTE options are used to specify index
attributes for primary and secondary storage engines. The options are reserved for future use.
For more information about permissible index_option values, see Section 15.1.15, “CREATE
INDEX Statement”. For more information about indexes, see Section 10.3.1, “How MySQL Uses
Indexes”.
• reference_definition
For reference_definition syntax details and examples, see Section 15.1.20.5, “FOREIGN KEY
Constraints”.
InnoDB and NDB tables support checking of foreign key constraints. The columns of the referenced
table must always be explicitly named. Both ON DELETE and ON UPDATE actions on foreign keys
are supported. For more detailed information and examples, see Section 15.1.20.5, “FOREIGN KEY
Constraints”.
For other storage engines, MySQL Server parses and ignores the FOREIGN KEY syntax in CREATE
TABLE statements.
Important
For users familiar with the ANSI/ISO SQL Standard, please note that no
storage engine, including InnoDB, recognizes or enforces the MATCH clause
used in referential integrity constraint definitions. Use of an explicit MATCH
clause does not have the specified effect, and also causes ON DELETE and
ON UPDATE clauses to be ignored. For these reasons, specifying MATCH
should be avoided.
The MATCH clause in the SQL standard controls how NULL values in a
composite (multiple-column) foreign key are handled when comparing to a
primary key. InnoDB essentially implements the semantics defined by MATCH
SIMPLE, which permit a foreign key to be all or partially NULL. In that case,
the (child table) row containing such a foreign key is permitted to be inserted,
and does not match any row in the referenced (parent) table. It is possible to
implement other semantics using triggers.
Additionally, MySQL requires that the referenced columns be indexed for
performance. However, InnoDB does not enforce any requirement that the
referenced columns be declared UNIQUE or NOT NULL. The handling of
foreign key references to nonunique keys or keys that contain NULL values is
not well defined for operations such as UPDATE or DELETE CASCADE. You
are advised to use foreign keys that reference only keys that are both UNIQUE
(or PRIMARY) and NOT NULL.
MySQL accepts “inline REFERENCES specifications” (as defined in the
SQL standard) where the references are defined as part of the column
specification. MySQL also accepts implicit references to the parent table's
primary key. For more information, see Section 15.1.20.5, “FOREIGN
KEY Constraints”, as well as Section 1.7.2.3, “FOREIGN KEY Constraint
Differences”.
• reference_option
For information about the RESTRICT, CASCADE, SET NULL, NO ACTION, and SET DEFAULT
options, see Section 15.1.20.5, “FOREIGN KEY Constraints”.
Table Options
Table options are used to optimize the behavior of the table. In most cases, you do not have to specify
any of them. These options apply to all storage engines unless otherwise indicated. Options that do not
apply to a given storage engine may be accepted and remembered as part of the table definition. Such
options then apply if you later use ALTER TABLE to convert the table to use a different storage engine.
• ENGINE
Specifies the storage engine for the table, using one of the names shown in the following table. The
engine name can be unquoted or quoted. The quoted name 'DEFAULT' is recognized but ignored.
Storage Engine
Description
InnoDB
Transaction-safe tables with row locking and
foreign keys. The default storage engine for
new tables. See Chapter 17, The InnoDB
Storage Engine, and in particular Section 17.1,
“Introduction to InnoDB” if you have MySQL
experience but are new to InnoDB.
MyISAM
The binary portable storage engine that is
primarily used for read-only or read-mostly
workloads. See Section 18.2, “The MyISAM
Storage Engine”.
MEMORY
The data for this storage engine is stored only
in memory. See Section 18.3, “The MEMORY
Storage Engine”.
CSV
Tables that store rows in comma-separated
values format. See Section 18.4, “The CSV
Storage Engine”.
ARCHIVE
The archiving storage engine. See Section 18.5,
“The ARCHIVE Storage Engine”.
EXAMPLE
An example engine. See Section 18.9, “The
EXAMPLE Storage Engine”.
FEDERATED
Storage engine that accesses remote tables.
See Section 18.8, “The FEDERATED Storage
Engine”.
HEAP
This is a synonym for MEMORY.
MERGE
A collection of MyISAM tables used as one table.
Also known as MRG_MyISAM. See Section 18.7,
“The MERGE Storage Engine”.
Storage Engine
Description
NDB
Clustered, fault-tolerant, memory-based tables,
supporting transactions and foreign keys. Also
known as NDBCLUSTER. See Chapter 25,
MySQL NDB Cluster 9.1.
By default, if a storage engine is specified that is not available, the statement fails with an error. You
can override this behavior by removing NO_ENGINE_SUBSTITUTION from the server SQL mode
(see Section 7.1.11, “Server SQL Modes”) so that MySQL allows substitution of the specified engine
with the default storage engine instead. Normally in such cases, this is InnoDB, which is the default
value for the default_storage_engine system variable. When NO_ENGINE_SUBSTITUTION is
disabled, a warning occurs if the storage engine specification is not honored.
• AUTOEXTEND_SIZE
Defines the amount by which InnoDB extends the size of the tablespace when it becomes full.
The setting must be a multiple of 4MB. The default setting is 0, which causes the tablespace to be
extended according to the implicit default behavior. For more information, see Section 17.6.3.9,
“Tablespace AUTOEXTEND_SIZE Configuration”.
• AUTO_INCREMENT
The initial AUTO_INCREMENT value for the table. In MySQL 9.1, this works for MyISAM, MEMORY,
InnoDB, and ARCHIVE tables. To set the first auto-increment value for engines that do not support
the AUTO_INCREMENT table option, insert a “dummy” row with a value one less than the desired
value after creating the table, and then delete the dummy row.
For engines that support the AUTO_INCREMENT table option in CREATE TABLE statements, you can
also use ALTER TABLE tbl_name AUTO_INCREMENT = N to reset the AUTO_INCREMENT value.
The value cannot be set lower than the maximum value currently in the column.
• AVG_ROW_LENGTH
An approximation of the average row length for your table. You need to set this only for large tables
with variable-size rows.
When you create a MyISAM table, MySQL uses the product of the MAX_ROWS and
AVG_ROW_LENGTH options to decide how big the resulting table is. If you don't specify either option,
the maximum size for MyISAM data and index files is 256TB by default. (If your operating system
does not support files that large, table sizes are constrained by the file size limit.) If you want to
keep down the pointer sizes to make the index smaller and faster and you don't really need big files,
you can decrease the default pointer size by setting the myisam_data_pointer_size system
variable. (See Section 7.1.8, “Server System Variables”.) If you want all your tables to be able
to grow above the default limit and are willing to have your tables slightly slower and larger than
necessary, you can increase the default pointer size by setting this variable. Setting the value to 7
permits table sizes up to 65,536TB.
• [DEFAULT] CHARACTER SET
Specifies a default character set for the table. CHARSET is a synonym for CHARACTER SET. If the
character set name is DEFAULT, the database character set is used.
• CHECKSUM
Set this to 1 if you want MySQL to maintain a live checksum for all rows (that is, a checksum that
MySQL updates automatically as the table changes). This makes the table a little slower to update,
but also makes it easier to find corrupted tables. The CHECKSUM TABLE statement reports the
checksum. (MyISAM only.)
• [DEFAULT] COLLATE
Specifies a default collation for the table.
• COMMENT
A comment for the table, up to 2048 characters long.
You can set the InnoDB MERGE_THRESHOLD value for a table using the table_option COMMENT
clause. See Section 17.8.11, “Configuring the Merge Threshold for Index Pages”.
Setting NDB_TABLE options. 
  The table comment in a CREATE TABLE that creates an NDB
table or an ALTER TABLE statement which alters one can also be used to specify one to four of the
NDB_TABLE options NOLOGGING, READ_BACKUP, PARTITION_BALANCE, or FULLY_REPLICATED
as a set of name-value pairs, separated by commas if need be, immediately following the string
NDB_TABLE= that begins the quoted comment text. An example statement using this syntax is
shown here (emphasized text):
CREATE TABLE t1 (
    c1 INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    c2 VARCHAR(100),
    c3 VARCHAR(100) )
ENGINE=NDB
COMMENT="NDB_TABLE=READ_BACKUP=0,PARTITION_BALANCE=FOR_RP_BY_NODE";
Spaces are not permitted within the quoted string. The string is case-insensitive.
The comment is displayed as part of the output of SHOW CREATE TABLE. The text of the comment is
also available as the TABLE_COMMENT column of the MySQL Information Schema TABLES table.
This comment syntax is also supported with ALTER TABLE statements for NDB tables. Keep in mind
that a table comment used with ALTER TABLE replaces any existing comment which the table might
have had previously.
Setting the MERGE_THRESHOLD option in table comments is not supported for NDB tables (it is
ignored).
For complete syntax information and examples, see Section 15.1.20.12, “Setting NDB Comment
Options”.
• COMPRESSION
The compression algorithm used for page level compression for InnoDB tables. Supported values
include Zlib, LZ4, and None. The COMPRESSION attribute was introduced with the transparent page
compression feature. Page compression is only supported with InnoDB tables that reside in file-per-
table tablespaces, and is only available on Linux and Windows platforms that support sparse files
and hole punching. For more information, see Section 17.9.2, “InnoDB Page Compression”.
• CONNECTION
The connection string for a FEDERATED table.
Note
Older versions of MySQL used a COMMENT option for the connection string.
• DATA DIRECTORY, INDEX DIRECTORY
For InnoDB, the DATA DIRECTORY='directory' clause permits creating tables outside of
the data directory. The innodb_file_per_table variable must be enabled to use the DATA
DIRECTORY clause. The full directory path must be specified, and known to InnoDB. For more
information, see Section 17.6.1.2, “Creating Tables Externally”.
When creating MyISAM tables, you can use the DATA DIRECTORY='directory' clause, the
INDEX DIRECTORY='directory' clause, or both. They specify where to put a MyISAM table's
data file and index file, respectively. Unlike InnoDB tables, MySQL does not create subdirectories
that correspond to the database name when creating a MyISAM table with a DATA DIRECTORY or
INDEX DIRECTORY option. Files are created in the directory that is specified.
You must have the FILE privilege to use the DATA DIRECTORY or INDEX DIRECTORY table option.
Important
Table-level DATA DIRECTORY and INDEX DIRECTORY options are ignored
for partitioned tables. (Bug #32091)
These options work only when you are not using the --skip-symbolic-links option. Your
operating system must also have a working, thread-safe realpath() call. See Section 10.12.2.2,
“Using Symbolic Links for MyISAM Tables on Unix”, for more complete information.
If a MyISAM table is created with no DATA DIRECTORY option, the .MYD file is created in the
database directory. By default, if MyISAM finds an existing .MYD file in this case, it overwrites it. The
same applies to .MYI files for tables created with no INDEX DIRECTORY option. To suppress this
behavior, start the server with the --keep_files_on_create option, in which case MyISAM does
not overwrite existing files and returns an error instead.
If a MyISAM table is created with a DATA DIRECTORY or INDEX DIRECTORY option and an existing
.MYD or .MYI file is found, MyISAM always returns an error, and does not overwrite a file in the
specified directory.
Important
You cannot use path names that contain the MySQL data directory with DATA
DIRECTORY or INDEX DIRECTORY. This includes partitioned tables and
individual table partitions. (See Bug #32167.)
• DELAY_KEY_WRITE
Set this to 1 if you want to delay key updates for the table until the table is closed. See the
description of the delay_key_write system variable in Section 7.1.8, “Server System Variables”.
(MyISAM only.)
• ENCRYPTION
The ENCRYPTION clause enables or disables page-level data encryption for an InnoDB table. A
keyring plugin must be installed and configured before encryption can be enabled. The ENCRYPTION
clause can be specified when creating a table in an a file-per-table tablespace, or when creating a
table in a general tablespace.
The ENCRYPTION option is supported only by the InnoDB storage engine; thus it works only
if the default storage engine is InnoDB, or if the CREATE TABLE statement also specifies
ENGINE=InnoDB. Otherwise the statement is rejected with ER_CHECK_NOT_IMPLEMENTED.
A table inherits the default schema encryption if an ENCRYPTION clause is not specified. If the
table_encryption_privilege_check variable is enabled, the TABLE_ENCRYPTION_ADMIN
privilege is required to create a table with an ENCRYPTION clause setting that differs from the default
schema encryption. When creating a table in a general tablespace, table and tablespace encryption
must match.
Specifying an ENCRYPTION clause with a value other than 'N' or '' is not permitted when using a
storage engine that does not support encryption.
For more information, see Section 17.13, “InnoDB Data-at-Rest Encryption”.
• The ENGINE_ATTRIBUTE and SECONDARY_ENGINE_ATTRIBUTE options are used to specify table
attributes for primary and secondary storage engines. The options are reserved for future use.
The value assigned to either of these options must be a string literal containing a valid JSON
document or an empty string (''). Invalid JSON is rejected.
CREATE TABLE t1 (c1 INT) ENGINE_ATTRIBUTE='{"key":"value"}';
ENGINE_ATTRIBUTE and SECONDARY_ENGINE_ATTRIBUTE values can be repeated without error.
In this case, the last specified value is used.
ENGINE_ATTRIBUTE and SECONDARY_ENGINE_ATTRIBUTE values are not checked by the server,
nor are they cleared when the table's storage engine is changed.
• INSERT_METHOD
If you want to insert data into a MERGE table, you must specify with INSERT_METHOD the table into
which the row should be inserted. INSERT_METHOD is an option useful for MERGE tables only. Use a
value of FIRST or LAST to have inserts go to the first or last table, or a value of NO to prevent inserts.
See Section 18.7, “The MERGE Storage Engine”.
• KEY_BLOCK_SIZE
For MyISAM tables, KEY_BLOCK_SIZE optionally specifies the size in bytes to use for index
key blocks. The value is treated as a hint; a different size could be used if necessary. A
KEY_BLOCK_SIZE value specified for an individual index definition overrides the table-level
KEY_BLOCK_SIZE value.
For InnoDB tables, KEY_BLOCK_SIZE specifies the page size in kilobytes to use for compressed
InnoDB tables. The KEY_BLOCK_SIZE value is treated as a hint; a different size could
be used by InnoDB if necessary. KEY_BLOCK_SIZE can only be less than or equal to the
innodb_page_size value. A value of 0 represents the default compressed page size, which is half
of the innodb_page_size value. Depending on innodb_page_size, possible KEY_BLOCK_SIZE
values include 0, 1, 2, 4, 8, and 16. See Section 17.9.1, “InnoDB Table Compression” for more
information.
Oracle recommends enabling innodb_strict_mode when specifying KEY_BLOCK_SIZE for
InnoDB tables. When innodb_strict_mode is enabled, specifying an invalid KEY_BLOCK_SIZE
value returns an error. If innodb_strict_mode is disabled, an invalid KEY_BLOCK_SIZE value
results in a warning, and the KEY_BLOCK_SIZE option is ignored.
The Create_options column in response to SHOW TABLE STATUS reports the actual
KEY_BLOCK_SIZE used by the table, as does SHOW CREATE TABLE.
InnoDB only supports KEY_BLOCK_SIZE at the table level.
KEY_BLOCK_SIZE is not supported with 32KB and 64KB innodb_page_size values. InnoDB
table compression does not support these pages sizes.
InnoDB does not support the KEY_BLOCK_SIZE option when creating temporary tables.
• MAX_ROWS
The maximum number of rows you plan to store in the table. This is not a hard limit, but rather a hint
to the storage engine that the table must be able to store at least this many rows.
Important
The use of MAX_ROWS with NDB tables to control the number of table
partitions is deprecated. It remains supported in later versions for
backward compatibility, but is subject to removal in a future release. Use
PARTITION_BALANCE instead; see Setting NDB_TABLE options.
The NDB storage engine treats this value as a maximum. If you plan to create very large NDB Cluster
tables (containing millions of rows), you should use this option to insure that NDB allocates sufficient
number of index slots in the hash table used for storing hashes of the table's primary keys by setting
MAX_ROWS = 2 * rows, where rows is the number of rows that you expect to insert into the table.
The maximum MAX_ROWS value is 4294967295; larger values are truncated to this limit.
• MIN_ROWS
The minimum number of rows you plan to store in the table. The MEMORY storage engine uses this
option as a hint about memory use.
• PACK_KEYS
Takes effect only with MyISAM tables. Set this option to 1 if you want to have smaller indexes.
This usually makes updates slower and reads faster. Setting the option to 0 disables all packing of
keys. Setting it to DEFAULT tells the storage engine to pack only long CHAR, VARCHAR, BINARY, or
VARBINARY columns.
If you do not use PACK_KEYS, the default is to pack strings, but not numbers. If you use
PACK_KEYS=1, numbers are packed as well.
When packing binary number keys, MySQL uses prefix compression:
• Every key needs one extra byte to indicate how many bytes of the previous key are the same for
the next key.
• The pointer to the row is stored in high-byte-first order directly after the key, to improve
compression.
This means that if you have many equal keys on two consecutive rows, all following “same” keys
usually only take two bytes (including the pointer to the row). Compare this to the ordinary case
where the following keys takes storage_size_for_key + pointer_size (where the pointer
size is usually 4). Conversely, you get a significant benefit from prefix compression only if you have
many numbers that are the same. If all keys are totally different, you use one byte more per key, if
the key is not a key that can have NULL values. (In this case, the packed key length is stored in the
same byte that is used to mark if a key is NULL.)
• PASSWORD
This option is unused.
• ROW_FORMAT
Defines the physical format in which the rows are stored.
When creating a table with strict mode disabled, the storage engine's default row format is used
if the specified row format is not supported. The actual row format of the table is reported in the
Row_format column in response to SHOW TABLE STATUS. The Create_options column shows
the row format that was specified in the CREATE TABLE statement, as does SHOW CREATE TABLE.
Row format choices differ depending on the storage engine used for the table.
For InnoDB tables:
• The default row format is defined by innodb_default_row_format, which has a default setting
of DYNAMIC. The default row format is used when the ROW_FORMAT option is not defined or when
ROW_FORMAT=DEFAULT is used.
If the ROW_FORMAT option is not defined, or if ROW_FORMAT=DEFAULT is used, operations
that rebuild a table also silently change the row format of the table to the default defined by
innodb_default_row_format. For more information, see Defining the Row Format of a Table.
• For more efficient InnoDB storage of data types, especially BLOB types, use the DYNAMIC. See
DYNAMIC Row Format for requirements associated with the DYNAMIC row format.
• To enable compression for InnoDB tables, specify ROW_FORMAT=COMPRESSED. The
ROW_FORMAT=COMPRESSED option is not supported when creating temporary tables. See
Section 17.9, “InnoDB Table and Page Compression” for requirements associated with the
COMPRESSED row format.
• The row format used in older versions of MySQL can still be requested by specifying the
REDUNDANT row format.
• When you specify a non-default ROW_FORMAT clause, consider also enabling the
innodb_strict_mode configuration option.
• ROW_FORMAT=FIXED is not supported. If ROW_FORMAT=FIXED is specified while
innodb_strict_mode is disabled, InnoDB issues a warning and assumes
ROW_FORMAT=DYNAMIC. If ROW_FORMAT=FIXED is specified while innodb_strict_mode is
enabled, which is the default, InnoDB returns an error.
• For additional information about InnoDB row formats, see Section 17.10, “InnoDB Row Formats”.
For MyISAM tables, the option value can be FIXED or DYNAMIC for static or variable-length row
format. myisampack sets the type to COMPRESSED. See Section 18.2.3, “MyISAM Table Storage
Formats”.
For NDB tables, the default ROW_FORMAT is DYNAMIC.
• START TRANSACTION
This is an internal-use table option, used to permit CREATE TABLE ... SELECT to be logged as a
single, atomic transaction in the binary log when using row-based replication with a storage engine
that supports atomic DDL. Only BINLOG, COMMIT, and ROLLBACK statements are permitted after
CREATE TABLE ... START TRANSACTION. For related information, see Section 15.1.1, “Atomic
Data Definition Statement Support”.
• STATS_AUTO_RECALC
Specifies whether to automatically recalculate persistent statistics for an InnoDB table. The
value DEFAULT causes the persistent statistics setting for the table to be determined by the
innodb_stats_auto_recalc configuration option. The value 1 causes statistics to be
recalculated when 10% of the data in the table has changed. The value 0 prevents automatic
recalculation for this table; with this setting, issue an ANALYZE TABLE statement to recalculate the
statistics after making substantial changes to the table. For more information about the persistent
statistics feature, see Section 17.8.10.1, “Configuring Persistent Optimizer Statistics Parameters”.
• STATS_PERSISTENT
Specifies whether to enable persistent statistics for an InnoDB table. The value DEFAULT causes
the persistent statistics setting for the table to be determined by the innodb_stats_persistent
configuration option. The value 1 enables persistent statistics for the table, while the value 0
turns off this feature. After enabling persistent statistics through a CREATE TABLE or ALTER
TABLE statement, issue an ANALYZE TABLE statement to calculate the statistics, after loading
representative data into the table. For more information about the persistent statistics feature, see
Section 17.8.10.1, “Configuring Persistent Optimizer Statistics Parameters”.
• STATS_SAMPLE_PAGES
The number of index pages to sample when estimating cardinality and other statistics for an indexed
column, such as those calculated by ANALYZE TABLE. For more information, see Section 17.8.10.1,
“Configuring Persistent Optimizer Statistics Parameters”.
• TABLESPACE
The TABLESPACE clause can be used to create an InnoDB table in an existing general tablespace,
a file-per-table tablespace, or the system tablespace.
CREATE TABLE tbl_name ... TABLESPACE [=] tablespace_name
The general tablespace that you specify must exist prior to using the TABLESPACE clause. For
information about general tablespaces, see Section 17.6.3.3, “General Tablespaces”.
The tablespace_name is a case-sensitive identifier. It may be quoted or unquoted. The forward
slash character (“/”) is not permitted. Names beginning with “innodb_” are reserved for special use.
To create a table in the system tablespace, specify innodb_system as the tablespace name.
CREATE TABLE tbl_name ... TABLESPACE [=] innodb_system
Using TABLESPACE [=] innodb_system, you can place a table of any uncompressed row format
in the system tablespace regardless of the innodb_file_per_table setting. For example, you
can add a table with ROW_FORMAT=DYNAMIC to the system tablespace using TABLESPACE [=]
innodb_system.
To create a table in a file-per-table tablespace, specify innodb_file_per_table as the
tablespace name.
CREATE TABLE tbl_name ... TABLESPACE [=] innodb_file_per_table
Note
If innodb_file_per_table is enabled, you need not specify
TABLESPACE=innodb_file_per_table to create an InnoDB file-per-table
tablespace. InnoDB tables are created in file-per-table tablespaces by default
when innodb_file_per_table is enabled.
The DATA DIRECTORY clause is permitted with CREATE TABLE ...
TABLESPACE=innodb_file_per_table but is otherwise not supported for use in combination
with the TABLESPACE clause. The directory specified in a DATA DIRECTORY clause must be known
to InnoDB. For more information, see Using the DATA DIRECTORY Clause.
Note
Support for TABLESPACE = innodb_file_per_table and TABLESPACE
= innodb_temporary clauses with CREATE TEMPORARY TABLE is
deprecated; expect it to be removed in a future version of MySQL.
The STORAGE table option is employed only with NDB tables. STORAGE determines the type of
storage used, and can be either of DISK or MEMORY.
TABLESPACE ... STORAGE DISK assigns a table to an NDB Cluster Disk Data tablespace.
STORAGE DISK cannot be used in CREATE TABLE unless preceded by TABLESPACE
tablespace_name.
For STORAGE MEMORY, the tablespace name is optional, thus, you can use TABLESPACE
tablespace_name STORAGE MEMORY or simply STORAGE MEMORY to specify explicitly that the
table is in-memory.
See Section 25.6.11, “NDB Cluster Disk Data Tables”, for more information.
• UNION
Used to access a collection of identical MyISAM tables as one. This works only with MERGE tables.
See Section 18.7, “The MERGE Storage Engine”.
You must have SELECT, UPDATE, and DELETE privileges for the tables you map to a MERGE table.
Note
Formerly, all tables used had to be in the same database as the MERGE table
itself. This restriction no longer applies.
Table Partitioning
partition_options can be used to control partitioning of the table created with CREATE TABLE.
Not all options shown in the syntax for partition_options at the beginning of this section
are available for all partitioning types. Please see the listings for the following individual types for
information specific to each type, and see Chapter 26, Partitioning, for more complete information
about the workings of and uses for partitioning in MySQL, as well as additional examples of table
creation and other statements relating to MySQL partitioning.
Partitions can be modified, merged, added to tables, and dropped from tables. For basic information
about the MySQL statements to accomplish these tasks, see Section 15.1.9, “ALTER TABLE
Statement”. For more detailed descriptions and examples, see Section 26.3, “Partition Management”.
• PARTITION BY
If used, a partition_options clause begins with PARTITION BY. This clause contains the
function that is used to determine the partition; the function returns an integer value ranging from 1 to
num, where num is the number of partitions. (The maximum number of user-defined partitions which
a table may contain is 1024; the number of subpartitions—discussed later in this section—is included
in this maximum.)
Note
The expression (expr) used in a PARTITION BY clause cannot refer to any
columns not in the table being created; such references are specifically not
permitted and cause the statement to fail with an error. (Bug #29444)
• HASH(expr)
Hashes one or more columns to create a key for placing and locating rows. expr is an expression
using one or more table columns. This can be any valid MySQL expression (including MySQL
functions) that yields a single integer value. For example, these are both valid CREATE TABLE
statements using PARTITION BY HASH:
CREATE TABLE t1 (col1 INT, col2 CHAR(5))
    PARTITION BY HASH(col1);
CREATE TABLE t1 (col1 INT, col2 CHAR(5), col3 DATETIME)
    PARTITION BY HASH ( YEAR(col3) );
You may not use either VALUES LESS THAN or VALUES IN clauses with PARTITION BY HASH.
PARTITION BY HASH uses the remainder of expr divided by the number of partitions (that is, the
modulus). For examples and additional information, see Section 26.2.4, “HASH Partitioning”.
The LINEAR keyword entails a somewhat different algorithm. In this case, the number of the partition
in which a row is stored is calculated as the result of one or more logical AND operations. For
discussion and examples of linear hashing, see Section 26.2.4.1, “LINEAR HASH Partitioning”.
• KEY(column_list)
This is similar to HASH, except that MySQL supplies the hashing function so as to guarantee an even
data distribution. The column_list argument is simply a list of 1 or more table columns (maximum:
16). This example shows a simple table partitioned by key, with 4 partitions:
CREATE TABLE tk (col1 INT, col2 CHAR(5), col3 DATE)
    PARTITION BY KEY(col3)
    PARTITIONS 4;
For tables that are partitioned by key, you can employ linear partitioning by using the LINEAR
keyword. This has the same effect as with tables that are partitioned by HASH. That is, the partition
number is found using the & operator rather than the modulus (see Section 26.2.4.1, “LINEAR
HASH Partitioning”, and Section 26.2.5, “KEY Partitioning”, for details). This example uses linear
partitioning by key to distribute data between 5 partitions:
CREATE TABLE tk (col1 INT, col2 CHAR(5), col3 DATE)
    PARTITION BY LINEAR KEY(col3)
    PARTITIONS 5;
The ALGORITHM={1 | 2} option is supported with [SUB]PARTITION BY [LINEAR] KEY.
ALGORITHM=1 causes the server to use the same key-hashing functions as MySQL 5.1;
ALGORITHM=2 means that the server employs the key-hashing functions implemented and used by
default for new KEY partitioned tables in MySQL 5.5 and later. (Partitioned tables created with the
key-hashing functions employed in MySQL 5.5 and later cannot be used by a MySQL 5.1 server.)
Not specifying the option has the same effect as using ALGORITHM=2. This option is intended for
use chiefly when upgrading or downgrading [LINEAR] KEY partitioned tables between MySQL
5.1 and later MySQL versions, or for creating tables partitioned by KEY or LINEAR KEY on a
MySQL 5.5 or later server which can be used on a MySQL 5.1 server. For more information, see
Section 15.1.9.1, “ALTER TABLE Partition Operations”.
mysqldump writes this option encased in versioned comments.
ALGORITHM=1 is shown when necessary in the output of SHOW CREATE TABLE using versioned
comments in the same manner as mysqldump. ALGORITHM=2 is always omitted from SHOW
CREATE TABLE output, even if this option was specified when creating the original table.
You may not use either VALUES LESS THAN or VALUES IN clauses with PARTITION BY KEY.
• RANGE(expr)
In this case, expr shows a range of values using a set of VALUES LESS THAN operators. When
using range partitioning, you must define at least one partition using VALUES LESS THAN. You
cannot use VALUES IN with range partitioning.
Note
For tables partitioned by RANGE, VALUES LESS THAN must be used with
either an integer literal value or an expression that evaluates to a single
integer value. In MySQL 9.1, you can overcome this limitation in a table that
is defined using PARTITION BY RANGE COLUMNS, as described later in this
section.
Suppose that you have a table that you wish to partition on a column containing year values,
according to the following scheme.
Partition Number:
Years Range:
0
1990 and earlier
1
1991 to 1994
2
1995 to 1998
3
1999 to 2002
4
2003 to 2005
5
2006 and later
A table implementing such a partitioning scheme can be realized by the CREATE TABLE statement
shown here:
CREATE TABLE t1 (
    year_col  INT,
    some_data INT
)
PARTITION BY RANGE (year_col) (
    PARTITION p0 VALUES LESS THAN (1991),
    PARTITION p1 VALUES LESS THAN (1995),
    PARTITION p2 VALUES LESS THAN (1999),
    PARTITION p3 VALUES LESS THAN (2002),
    PARTITION p4 VALUES LESS THAN (2006),
    PARTITION p5 VALUES LESS THAN MAXVALUE
);
PARTITION ... VALUES LESS THAN ... statements work in a consecutive fashion. VALUES
LESS THAN MAXVALUE works to specify “leftover” values that are greater than the maximum value
otherwise specified.
VALUES LESS THAN clauses work sequentially in a manner similar to that of the case portions of a
switch ... case block (as found in many programming languages such as C, Java, and PHP).
That is, the clauses must be arranged in such a way that the upper limit specified in each successive
VALUES LESS THAN is greater than that of the previous one, with the one referencing MAXVALUE
coming last of all in the list.
• RANGE COLUMNS(column_list)
This variant on RANGE facilitates partition pruning for queries using range conditions on multiple
columns (that is, having conditions such as WHERE a = 1 AND b < 10 or WHERE a = 1 AND
b = 10 AND c < 10). It enables you to specify value ranges in multiple columns by using a list
of columns in the COLUMNS clause and a set of column values in each PARTITION ... VALUES
LESS THAN (value_list) partition definition clause. (In the simplest case, this set consists of a
single column.) The maximum number of columns that can be referenced in the column_list and
value_list is 16.
The column_list used in the COLUMNS clause may contain only names of columns; each column
in the list must be one of the following MySQL data types: the integer types; the string types; and
time or date column types. Columns using BLOB, TEXT, SET, ENUM, BIT, or spatial data types are
not permitted; columns that use floating-point number types are also not permitted. You also may not
use functions or arithmetic expressions in the COLUMNS clause.
The VALUES LESS THAN clause used in a partition definition must specify a literal value for each
column that appears in the COLUMNS() clause; that is, the list of values used for each VALUES
LESS THAN clause must contain the same number of values as there are columns listed in the
COLUMNS clause. An attempt to use more or fewer values in a VALUES LESS THAN clause than
there are in the COLUMNS clause causes the statement to fail with the error Inconsistency
in usage of column lists for partitioning.... You cannot use NULL for any value
appearing in VALUES LESS THAN. It is possible to use MAXVALUE more than once for a given
column other than the first, as shown in this example:
CREATE TABLE rc (
    a INT NOT NULL,
    b INT NOT NULL
)
PARTITION BY RANGE COLUMNS(a,b) (
    PARTITION p0 VALUES LESS THAN (10,5),
    PARTITION p1 VALUES LESS THAN (20,10),
    PARTITION p2 VALUES LESS THAN (50,MAXVALUE),
    PARTITION p3 VALUES LESS THAN (65,MAXVALUE),
    PARTITION p4 VALUES LESS THAN (MAXVALUE,MAXVALUE)
);
Each value used in a VALUES LESS THAN value list must match the type of the corresponding
column exactly; no conversion is made. For example, you cannot use the string '1' for a value that
matches a column that uses an integer type (you must use the numeral 1 instead), nor can you use
the numeral 1 for a value that matches a column that uses a string type (in such a case, you must
use a quoted string: '1').
For more information, see Section 26.2.1, “RANGE Partitioning”, and Section 26.4, “Partition
Pruning”.
• LIST(expr)
This is useful when assigning partitions based on a table column with a restricted set of possible
values, such as a state or country code. In such a case, all rows pertaining to a certain state or
country can be assigned to a single partition, or a partition can be reserved for a certain set of states
or countries. It is similar to RANGE, except that only VALUES IN may be used to specify permissible
values for each partition.
VALUES IN is used with a list of values to be matched. For instance, you could create a partitioning
scheme such as the following:
CREATE TABLE client_firms (
    id   INT,
    name VARCHAR(35)
)
PARTITION BY LIST (id) (
    PARTITION r0 VALUES IN (1, 5, 9, 13, 17, 21),
    PARTITION r1 VALUES IN (2, 6, 10, 14, 18, 22),
    PARTITION r2 VALUES IN (3, 7, 11, 15, 19, 23),
    PARTITION r3 VALUES IN (4, 8, 12, 16, 20, 24)
);
When using list partitioning, you must define at least one partition using VALUES IN. You cannot use
VALUES LESS THAN with PARTITION BY LIST.
Note
For tables partitioned by LIST, the value list used with VALUES IN must
consist of integer values only. In MySQL 9.1, you can overcome this limitation
using partitioning by LIST COLUMNS, which is described later in this section.
• LIST COLUMNS(column_list)
This variant on LIST facilitates partition pruning for queries using comparison conditions on multiple
columns (that is, having conditions such as WHERE a = 5 AND b = 5 or WHERE a = 1 AND
b = 10 AND c = 5). It enables you to specify values in multiple columns by using a list of
columns in the COLUMNS clause and a set of column values in each PARTITION ... VALUES IN
(value_list) partition definition clause.
The rules governing regarding data types for the column list used in LIST
COLUMNS(column_list) and the value list used in VALUES IN(value_list) are the same
as those for the column list used in RANGE COLUMNS(column_list) and the value list used
in VALUES LESS THAN(value_list), respectively, except that in the VALUES IN clause,
MAXVALUE is not permitted, and you may use NULL.
There is one important difference between the list of values used for VALUES IN with PARTITION
BY LIST COLUMNS as opposed to when it is used with PARTITION BY LIST. When used with
PARTITION BY LIST COLUMNS, each element in the VALUES IN clause must be a set of column
values; the number of values in each set must be the same as the number of columns used in the
COLUMNS clause, and the data types of these values must match those of the columns (and occur in
the same order). In the simplest case, the set consists of a single column. The maximum number of
columns that can be used in the column_list and in the elements making up the value_list is
16.
The table defined by the following CREATE TABLE statement provides an example of a table using
LIST COLUMNS partitioning:
CREATE TABLE lc (
    a INT NULL,
    b INT NULL
)
PARTITION BY LIST COLUMNS(a,b) (
    PARTITION p0 VALUES IN( (0,0), (NULL,NULL) ),
    PARTITION p1 VALUES IN( (0,1), (0,2), (0,3), (1,1), (1,2) ),
    PARTITION p2 VALUES IN( (1,0), (2,0), (2,1), (3,0), (3,1) ),
    PARTITION p3 VALUES IN( (1,3), (2,2), (2,3), (3,2), (3,3) )
);
• PARTITIONS num
The number of partitions may optionally be specified with a PARTITIONS num clause, where num
is the number of partitions. If both this clause and any PARTITION clauses are used, num must be
equal to the total number of any partitions that are declared using PARTITION clauses.
Note
Whether or not you use a PARTITIONS clause in creating a table that is
partitioned by RANGE or LIST, you must still include at least one PARTITION
VALUES clause in the table definition (see below).
• SUBPARTITION BY
A partition may optionally be divided into a number of subpartitions. This can be indicated by using
the optional SUBPARTITION BY clause. Subpartitioning may be done by HASH or KEY. Either of
these may be LINEAR. These work in the same way as previously described for the equivalent
partitioning types. (It is not possible to subpartition by LIST or RANGE.)
The number of subpartitions can be indicated using the SUBPARTITIONS keyword followed by an
integer value.
• Rigorous checking of the value used in PARTITIONS or SUBPARTITIONS clauses is applied and this
value must adhere to the following rules:
• The value must be a positive, nonzero integer.
• No leading zeros are permitted.
• The value must be an integer literal, and cannot not be an expression. For example, PARTITIONS
0.2E+01 is not permitted, even though 0.2E+01 evaluates to 2. (Bug #15890)
• partition_definition
Each partition may be individually defined using a partition_definition clause. The individual
parts making up this clause are as follows:
• PARTITION partition_name
Specifies a logical name for the partition.
• VALUES
For range partitioning, each partition must include a VALUES LESS THAN clause; for list
partitioning, you must specify a VALUES IN clause for each partition. This is used to determine
which rows are to be stored in this partition. See the discussions of partitioning types in
Chapter 26, Partitioning, for syntax examples.
• [STORAGE] ENGINE
MySQL accepts a [STORAGE] ENGINE option for both PARTITION and SUBPARTITION.
Currently, the only way in which this option can be used is to set all partitions or all subpartitions
to the same storage engine, and an attempt to set different storage engines for partitions
or subpartitions in the same table raises the error ERROR 1469 (HY000): The mix of
handlers in the partitions is not permitted in this version of MySQL.
• COMMENT
An optional COMMENT clause may be used to specify a string that describes the partition. Example:
COMMENT = 'Data for the years previous to 1999'
The maximum length for a partition comment is 1024 characters.
• DATA DIRECTORY and INDEX DIRECTORY
DATA DIRECTORY and INDEX DIRECTORY may be used to indicate the directory where,
respectively, the data and indexes for this partition are to be stored. Both the data_dir and the
index_dir must be absolute system path names.
The directory specified in a DATA DIRECTORY clause must be known to InnoDB. For more
information, see Using the DATA DIRECTORY Clause.
You must have the FILE privilege to use the DATA DIRECTORY or INDEX DIRECTORY partition
option.
Example:
CREATE TABLE th (id INT, name VARCHAR(30), adate DATE)
PARTITION BY LIST(YEAR(adate))
(
  PARTITION p1999 VALUES IN (1995, 1999, 2003)
    DATA DIRECTORY = '/var/appdata/95/data'
    INDEX DIRECTORY = '/var/appdata/95/idx',
  PARTITION p2000 VALUES IN (1996, 2000, 2004)
    DATA DIRECTORY = '/var/appdata/96/data'
    INDEX DIRECTORY = '/var/appdata/96/idx',
  PARTITION p2001 VALUES IN (1997, 2001, 2005)
    DATA DIRECTORY = '/var/appdata/97/data'
    INDEX DIRECTORY = '/var/appdata/97/idx',
  PARTITION p2002 VALUES IN (1998, 2002, 2006)
    DATA DIRECTORY = '/var/appdata/98/data'
    INDEX DIRECTORY = '/var/appdata/98/idx'
);
DATA DIRECTORY and INDEX DIRECTORY behave in the same way as in the CREATE TABLE
statement's table_option clause as used for MyISAM tables.
One data directory and one index directory may be specified per partition. If left unspecified, the
data and indexes are stored by default in the table's database directory.
The DATA DIRECTORY and INDEX DIRECTORY options are ignored for creating partitioned tables
if NO_DIR_IN_CREATE is in effect.
• MAX_ROWS and MIN_ROWS
May be used to specify, respectively, the maximum and minimum number of rows to be stored in
the partition. The values for max_number_of_rows and min_number_of_rows must be positive
integers. As with the table-level options with the same names, these act only as “suggestions” to
the server and are not hard limits.
• TABLESPACE
May be used to designate an InnoDB file-per-table tablespace for the partition by specifying
TABLESPACE `innodb_file_per_table`. All partitions must belong to the same storage
engine.
Placing InnoDB table partitions in shared InnoDB tablespaces is not supported. Shared
tablespaces include the InnoDB system tablespace and general tablespaces.
• subpartition_definition
The partition definition may optionally contain one or more subpartition_definition clauses.
Each of these consists at a minimum of the SUBPARTITION name, where name is an identifier for
the subpartition. Except for the replacement of the PARTITION keyword with SUBPARTITION, the
syntax for a subpartition definition is identical to that for a partition definition.
Subpartitioning must be done by HASH or KEY, and can be done only on RANGE or LIST partitions.
See Section 26.2.6, “Subpartitioning”.
Partitioning by Generated Columns
Partitioning by generated columns is permitted. For example:
CREATE TABLE t1 (
  s1 INT,
  s2 INT AS (EXP(s1)) STORED
)
PARTITION BY LIST (s2) (
  PARTITION p1 VALUES IN (1)
);
Partitioning sees a generated column as a regular column, which enables workarounds for limitations
on functions that are not permitted for partitioning (see Section 26.6.3, “Partitioning Limitations Relating
to Functions”). The preceding example demonstrates this technique: EXP() cannot be used directly in
the PARTITION BY clause, but a generated column defined using EXP() is permitted.
15.1.20.1 Files Created by CREATE TABLE
For an InnoDB table created in a file-per-table tablespace or general tablespace, table data and
associated indexes are stored in a .ibd file in the database directory. When an InnoDB table is created
in the system tablespace, table data and indexes are stored in the ibdata* files that represent the
system tablespace. The innodb_file_per_table option controls whether tables are created in file-
per-table tablespaces or the system tablespace, by default. The TABLESPACE option can be used to
place a table in a file-per-table tablespace, general tablespace, or the system tablespace, regardless of
the innodb_file_per_table setting.
For MyISAM tables, the storage engine creates data and index files. Thus, for each MyISAM table
tbl_name, there are two disk files.
File
Purpose
tbl_name.MYD
Data file
tbl_name.MYI
Index file
Chapter 18, Alternative Storage Engines, describes what files each storage engine creates to represent
tables. If a table name contains special characters, the names for the table files contain encoded
versions of those characters as described in Section 11.2.4, “Mapping of Identifiers to File Names”.
15.1.20.2 CREATE TEMPORARY TABLE Statement
You can use the TEMPORARY keyword when creating a table. A TEMPORARY table is visible only within
the current session, and is dropped automatically when the session is closed. This means that two
different sessions can use the same temporary table name without conflicting with each other or with
an existing non-TEMPORARY table of the same name. (The existing table is hidden until the temporary
table is dropped.)
InnoDB does not support compressed temporary tables. When innodb_strict_mode is enabled
(the default), CREATE TEMPORARY TABLE returns an error if ROW_FORMAT=COMPRESSED or
KEY_BLOCK_SIZE is specified. If innodb_strict_mode is disabled, warnings are issued and the
temporary table is created using a non-compressed row format. The innodb_file_per-table
option does not affect the creation of InnoDB temporary tables.
CREATE TABLE causes an implicit commit, except when used with the TEMPORARY keyword. See
Section 15.3.3, “Statements That Cause an Implicit Commit”.
TEMPORARY tables have a very loose relationship with databases (schemas). Dropping a database
does not automatically drop any TEMPORARY tables created within that database.
To create a temporary table, you must have the CREATE TEMPORARY TABLES privilege. After a
session has created a temporary table, the server performs no further privilege checks on the table.
The creating session can perform any operation on the table, such as DROP TABLE, INSERT, UPDATE,
or SELECT.
One implication of this behavior is that a session can manipulate its temporary tables even if the
current user has no privilege to create them. Suppose that the current user does not have the CREATE
TEMPORARY TABLES privilege but is able to execute a definer-context stored procedure that executes
with the privileges of a user who does have CREATE TEMPORARY TABLES and that creates a
temporary table. While the procedure executes, the session uses the privileges of the defining user.
After the procedure returns, the effective privileges revert to those of the current user, which can still
see the temporary table and perform any operation on it.
You cannot use CREATE TEMPORARY TABLE ... LIKE to create an empty table based
on the definition of a table that resides in the mysql tablespace, InnoDB system tablespace
(innodb_system), or a general tablespace. The tablespace definition for such a table includes a
TABLESPACE attribute that defines the tablespace where the table resides, and the aforementioned
tablespaces do not support temporary tables. To create a temporary table based on the definition of
such a table, use this syntax instead:
CREATE TEMPORARY TABLE new_tbl SELECT * FROM orig_tbl LIMIT 0;
Note
Support for TABLESPACE = innodb_file_per_table and TABLESPACE =
innodb_temporary clauses with CREATE TEMPORARY TABLE is deprecated;
expect it to be removed in a future version of MySQL.
15.1.20.3 CREATE TABLE ... LIKE Statement
Use CREATE TABLE ... LIKE to create an empty table based on the definition of another table,
including any column attributes and indexes defined in the original table:
CREATE TABLE new_tbl LIKE orig_tbl;
The copy is created using the same version of the table storage format as the original table. The
SELECT privilege is required on the original table.
LIKE works only for base tables, not for views.
Important
You cannot execute CREATE TABLE or CREATE TABLE ... LIKE while a
LOCK TABLES statement is in effect.
CREATE TABLE ... LIKE makes the same checks as CREATE TABLE. This
means that if the current SQL mode is different from the mode in effect when
the original table was created, the table definition might be considered invalid
for the new mode and cause the statement to fail.
For CREATE TABLE ... LIKE, the destination table preserves generated column information from
the original table.
For CREATE TABLE ... LIKE, the destination table preserves expression default values from the
original table.
For CREATE TABLE ... LIKE, the destination table preserves CHECK constraints from the original
table, except that all the constraint names are generated.
CREATE TABLE ... LIKE does not preserve any DATA DIRECTORY or INDEX DIRECTORY table
options that were specified for the original table, or any foreign key definitions.
If the original table is a TEMPORARY table, CREATE TABLE ... LIKE does not preserve TEMPORARY.
To create a TEMPORARY destination table, use CREATE TEMPORARY TABLE ... LIKE.
CREATE TABLE ... LIKE operations apply all ENGINE_ATTRIBUTE and
SECONDARY_ENGINE_ATTRIBUTE values to the new table.
15.1.20.4 CREATE TABLE ... SELECT Statement
You can create one table from another by adding a SELECT statement at the end of the CREATE
TABLE statement:
CREATE TABLE new_tbl [AS] SELECT * FROM orig_tbl;
MySQL creates new columns for all elements in the SELECT. For example:
mysql> CREATE TABLE test (a INT NOT NULL AUTO_INCREMENT,
    ->        PRIMARY KEY (a), KEY(b))
    ->        ENGINE=InnoDB SELECT b,c FROM test2;
This creates an InnoDB table with three columns, a, b, and c. The ENGINE option is part of the
CREATE TABLE statement, and should not be used following the SELECT; this would result in a syntax
error. The same is true for other CREATE TABLE options such as CHARSET.
Notice that the columns from the SELECT statement are appended to the right side of the table, not
overlapped onto it. Take the following example:
mysql> SELECT * FROM foo;
+---+
| n |
+---+
| 1 |
+---+
mysql> CREATE TABLE bar (m INT) SELECT n FROM foo;
Query OK, 1 row affected (0.02 sec)
Records: 1  Duplicates: 0  Warnings: 0
mysql> SELECT * FROM bar;
+------+---+
| m    | n |
+------+---+
| NULL | 1 |
+------+---+
1 row in set (0.00 sec)
For each row in table foo, a row is inserted in bar with the values from foo and default values for the
new columns.
In a table resulting from CREATE TABLE ... SELECT, columns named only in the CREATE TABLE
part come first. Columns named in both parts or only in the SELECT part come after that. The data type
of SELECT columns can be overridden by also specifying the column in the CREATE TABLE part.
For storage engines that support both atomic DDL and foreign key constraints, creation of foreign keys
is not permitted in CREATE TABLE ... SELECT statements when row-based replication is in use.
Foreign key constraints can be added later using ALTER TABLE.
You can precede the SELECT by IGNORE or REPLACE to indicate how to handle rows that duplicate
unique key values. With IGNORE, rows that duplicate an existing row on a unique key value are
discarded. With REPLACE, new rows replace rows that have the same unique key value. If neither
IGNORE nor REPLACE is specified, duplicate unique key values result in an error. For more information,
see The Effect of IGNORE on Statement Execution.
You can also use a VALUES statement in the SELECT part of CREATE TABLE ... SELECT; the
VALUES portion of the statement must include a table alias using an AS clause. To name the columns
coming from VALUES, supply column aliases with the table alias; otherwise, the default column names
column_0, column_1, column_2, ..., are used.
Otherwise, naming of columns in the table thus created follows the same rules as described previously
in this section. Examples:
mysql> CREATE TABLE tv1
     >     SELECT * FROM (VALUES ROW(1,3,5), ROW(2,4,6)) AS v;
mysql> TABLE tv1;
+----------+----------+----------+
| column_0 | column_1 | column_2 |
+----------+----------+----------+
|        1 |        3 |        5 |
|        2 |        4 |        6 |
+----------+----------+----------+
mysql> CREATE TABLE tv2
     >     SELECT * FROM (VALUES ROW(1,3,5), ROW(2,4,6)) AS v(x,y,z);
mysql> TABLE tv2;
+---+---+---+
| x | y | z |
+---+---+---+
| 1 | 3 | 5 |
| 2 | 4 | 6 |
+---+---+---+
mysql> CREATE TABLE tv3 (a INT, b INT, c INT)
     >     SELECT * FROM (VALUES ROW(1,3,5), ROW(2,4,6)) AS v(x,y,z);
mysql> TABLE tv3;
+------+------+------+----------+----------+----------+
| a    | b    | c    |        x |        y |        z |
+------+------+------+----------+----------+----------+
| NULL | NULL | NULL |        1 |        3 |        5 |
| NULL | NULL | NULL |        2 |        4 |        6 |
+------+------+------+----------+----------+----------+
mysql> CREATE TABLE tv4 (a INT, b INT, c INT)
     >     SELECT * FROM (VALUES ROW(1,3,5), ROW(2,4,6)) AS v(x,y,z);
mysql> TABLE tv4;
+------+------+------+---+---+---+
| a    | b    | c    | x | y | z |
+------+------+------+---+---+---+
| NULL | NULL | NULL | 1 | 3 | 5 |
| NULL | NULL | NULL | 2 | 4 | 6 |
+------+------+------+---+---+---+
mysql> CREATE TABLE tv5 (a INT, b INT, c INT)
     >     SELECT * FROM (VALUES ROW(1,3,5), ROW(2,4,6)) AS v(a,b,c);
mysql> TABLE tv5;
+------+------+------+
| a    | b    | c    |
+------+------+------+
|    1 |    3 |    5 |
|    2 |    4 |    6 |
+------+------+------+
When selecting all columns and using the default column names, you can omit SELECT *, so the
statement just used to create table tv1 can also be written as shown here:
mysql> CREATE TABLE tv1 VALUES ROW(1,3,5), ROW(2,4,6);
mysql> TABLE tv1;
+----------+----------+----------+
| column_0 | column_1 | column_2 |
+----------+----------+----------+
|        1 |        3 |        5 |
|        2 |        4 |        6 |
+----------+----------+----------+
When using VALUES as the source of the SELECT, all columns are always selected into the new table,
and individual columns cannot be selected as they can be when selecting from a named table; each of
the following statements produces an error (ER_OPERAND_COLUMNS):
CREATE TABLE tvx
    SELECT (x,z) FROM (VALUES ROW(1,3,5), ROW(2,4,6)) AS v(x,y,z);
CREATE TABLE tvx (a INT, c INT)
    SELECT (x,z) FROM (VALUES ROW(1,3,5), ROW(2,4,6)) AS v(x,y,z);
Similarly, you can use a TABLE statement in place of the SELECT. This follows the same rules as with
VALUES; all columns of the source table and their names in the source table are always inserted into
the new table. Examples:
mysql> TABLE t1;
+----+----+
| a  | b  |
+----+----+
|  1 |  2 |
|  6 |  7 |
| 10 | -4 |
| 14 |  6 |
+----+----+
mysql> CREATE TABLE tt1 TABLE t1;
mysql> TABLE tt1;
+----+----+
| a  | b  |
+----+----+
|  1 |  2 |
|  6 |  7 |
| 10 | -4 |
| 14 |  6 |
+----+----+
mysql> CREATE TABLE tt2 (x INT) TABLE t1;
mysql> TABLE tt2;
+------+----+----+
| x    | a  | b  |
+------+----+----+
| NULL |  1 |  2 |
| NULL |  6 |  7 |
| NULL | 10 | -4 |
| NULL | 14 |  6 |
+------+----+----+
Because the ordering of the rows in the underlying SELECT statements cannot always be determined,
CREATE TABLE ... IGNORE SELECT and CREATE TABLE ... REPLACE SELECT statements are
flagged as unsafe for statement-based replication. Such statements produce a warning in the error log
when using statement-based mode and are written to the binary log using the row-based format when
using MIXED mode. See also Section 19.2.1.1, “Advantages and Disadvantages of Statement-Based
and Row-Based Replication”.
CREATE TABLE ... SELECT does not automatically create any indexes for you. This is done
intentionally to make the statement as flexible as possible. If you want to have indexes in the created
table, you should specify these before the SELECT statement:
mysql> CREATE TABLE bar (UNIQUE (n)) SELECT n FROM foo;
For CREATE TABLE ... SELECT, the destination table does not preserve information about whether
columns in the selected-from table are generated columns. The SELECT part of the statement cannot
assign values to generated columns in the destination table.
For CREATE TABLE ... SELECT, the destination table does preserve expression default values from
the original table.
Some conversion of data types might occur. For example, the AUTO_INCREMENT attribute is not
preserved, and VARCHAR columns can become CHAR columns. Retrained attributes are NULL (or NOT
NULL) and, for those columns that have them, CHARACTER SET, COLLATION, COMMENT, and the
DEFAULT clause.
When creating a table with CREATE TABLE ... SELECT, make sure to alias any function calls or
expressions in the query. If you do not, the CREATE statement might fail or result in undesirable column
names.
CREATE TABLE artists_and_works
  SELECT artist.name, COUNT(work.artist_id) AS number_of_works
  FROM artist LEFT JOIN work ON artist.id = work.artist_id
  GROUP BY artist.id;
You can also explicitly specify the data type for a column in the created table:
CREATE TABLE foo (a TINYINT NOT NULL) SELECT b+1 AS a FROM bar;
For CREATE TABLE ... SELECT, if IF NOT EXISTS is given and the target table exists, nothing is
inserted into the destination table, and the statement is not logged.
To ensure that the binary log can be used to re-create the original tables, MySQL does not permit
concurrent inserts during CREATE TABLE ... SELECT. For more information, see Section 15.1.1,
“Atomic Data Definition Statement Support”.
You cannot use FOR UPDATE as part of the SELECT in a statement such as CREATE TABLE
new_table SELECT ... FROM old_table .... If you attempt to do so, the statement fails.
CREATE TABLE ... SELECT operations apply ENGINE_ATTRIBUTE and
SECONDARY_ENGINE_ATTRIBUTE values to columns only. Table and index ENGINE_ATTRIBUTE and
SECONDARY_ENGINE_ATTRIBUTE values are not applied to the new table unless specified explicitly.
15.1.20.5 FOREIGN KEY Constraints
MySQL supports foreign keys, which permit cross-referencing related data across tables, and foreign
key constraints, which help keep the related data consistent.
A foreign key relationship involves a parent table that holds the initial column values, and a child table
with column values that reference the parent column values. A foreign key constraint is defined on the
child table.
The essential syntax for a defining a foreign key constraint in a CREATE TABLE or ALTER TABLE
statement includes the following:
[CONSTRAINT [symbol]] FOREIGN KEY
    [index_name] (col_name, ...)
    REFERENCES tbl_name (col_name,...)
    [ON DELETE reference_option]
    [ON UPDATE reference_option]
reference_option:
    RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT
Foreign key constraint usage is described under the following topics in this section:
• Identifiers
• Conditions and Restrictions
• Referential Actions
• Foreign Key Constraint Examples
• Adding Foreign Key Constraints
• Dropping Foreign Key Constraints
• Foreign Key Checks
• Locking
• Foreign Key Definitions and Metadata
• Foreign Key Errors
Identifiers
Foreign key constraint naming is governed by the following rules:
• The CONSTRAINT symbol value is used, if defined.
• If the CONSTRAINT symbol clause is not defined, or a symbol is not included following the
CONSTRAINT keyword, a constraint name name is generated automatically.
If the CONSTRAINT symbol clause is not defined, or a symbol is not included following the
CONSTRAINT keyword, both InnoDB and NDB storage engines ignore FOREIGN_KEY index_name.
• The CONSTRAINT symbol value, if defined, must be unique in the database. A duplicate
symbol results in an error similar to: ERROR 1005 (HY000): Can't create table
'test.fk1' (errno: 121).
• NDB Cluster stores foreign key names using the same lettercase with which they are created.
Table and column identifiers in a FOREIGN KEY ... REFERENCES clause can be quoted within
backticks (`). Alternatively, double quotation marks (") can be used if the ANSI_QUOTES SQL mode is
enabled. The lower_case_table_names system variable setting is also taken into account.
Conditions and Restrictions
Foreign key constraints are subject to the following conditions and restrictions:
• Parent and child tables must use the same storage engine, and they cannot be defined as temporary
tables.
• Creating a foreign key constraint requires the REFERENCES privilege on the parent table.
• Corresponding columns in the foreign key and the referenced key must have similar data types. The
size and sign of fixed precision types such as INTEGER and DECIMAL must be the same. The length
of string types need not be the same. For nonbinary (character) string columns, the character set and
collation must be the same.
• MySQL supports foreign key references between one column and another within a table. (A column
cannot have a foreign key reference to itself.) In these cases, a “child table record” refers to a
dependent record within the same table.
• MySQL requires indexes on foreign keys and referenced keys so that foreign key checks can be
fast and not require a table scan. In the referencing table, there must be an index where the foreign
key columns are listed as the first columns in the same order. Such an index is created on the
referencing table automatically if it does not exist. This index might be silently dropped later if you
create another index that can be used to enforce the foreign key constraint. index_name, if given, is
used as described previously.
• Previously, InnoDB allowed a foreign key to reference any index column or group of columns,
even a non-unique index or partial index, an extension of standard SQL. This is still allowed
for backwards compatibility, but is now deprecated; in addition, it must be enabled by setting
restrict_fk_on_non_standard_key. If this is done, there must still be an index in the
referenced table where the referenced columns are the first columns in the same order. Hidden
columns that InnoDB adds to an index are also considered in such cases (see Section 17.6.2.1,
“Clustered and Secondary Indexes”). You should expect support for use of nonstandard keys to be
removed in a future version of MySQL, and migrate away from their use.
NDB always requires an explicit unique key (or primary key) on any column referenced as a foreign
key.
• Index prefixes on foreign key columns are not supported. Consequently, BLOB and TEXT columns
cannot be included in a foreign key because indexes on those columns must always include a prefix
length.
• InnoDB does not currently support foreign keys for tables with user-defined partitioning. This
includes both parent and child tables.
This restriction does not apply for NDB tables that are partitioned by KEY or LINEAR KEY (the only
user partitioning types supported by the NDB storage engine); these may have foreign key references
or be the targets of such references.
• A table in a foreign key relationship cannot be altered to use another storage engine. To change the
storage engine, you must drop any foreign key constraints first.
• A foreign key constraint cannot reference a virtual generated column.
For information about how the MySQL implementation of foreign key constraints differs from the SQL
standard, see Section 1.7.2.3, “FOREIGN KEY Constraint Differences”.
Referential Actions
When an UPDATE or DELETE operation affects a key value in the parent table that has matching rows
in the child table, the result depends on the referential action specified by ON UPDATE and ON DELETE
subclauses of the FOREIGN KEY clause. Referential actions include:
• CASCADE: Delete or update the row from the parent table and automatically delete or update the
matching rows in the child table. Both ON DELETE CASCADE and ON UPDATE CASCADE are
supported. Between two tables, do not define several ON UPDATE CASCADE clauses that act on the
same column in the parent table or in the child table.
If a FOREIGN KEY clause is defined on both tables in a foreign key relationship, making both tables
a parent and child, an ON UPDATE CASCADE or ON DELETE CASCADE subclause defined for one
FOREIGN KEY clause must be defined for the other in order for cascading operations to succeed.
If an ON UPDATE CASCADE or ON DELETE CASCADE subclause is only defined for one FOREIGN
KEY clause, cascading operations fail with an error.
Note
Cascaded foreign key actions do not activate triggers.
• SET NULL: Delete or update the row from the parent table and set the foreign key column or
columns in the child table to NULL. Both ON DELETE SET NULL and ON UPDATE SET NULL
clauses are supported.
If you specify a SET NULL action, make sure that you have not declared the columns in the child
table as NOT NULL.
• RESTRICT: Rejects the delete or update operation for the parent table. Specifying RESTRICT (or NO
ACTION) is the same as omitting the ON DELETE or ON UPDATE clause.
• NO ACTION: A keyword from standard SQL. For InnoDB, this is equivalent to RESTRICT; the delete
or update operation for the parent table is immediately rejected if there is a related foreign key value
in the referenced table. NDB supports deferred checks, and NO ACTION specifies a deferred check;
when this is used, constraint checks are not performed until commit time. Note that for NDB tables,
this causes all foreign key checks made for both parent and child tables to be deferred.
• SET DEFAULT: This action is recognized by the MySQL parser, but both InnoDB and NDB reject
table definitions containing ON DELETE SET DEFAULT or ON UPDATE SET DEFAULT clauses.
For storage engines that support foreign keys, MySQL rejects any INSERT or UPDATE operation that
attempts to create a foreign key value in a child table if there is no matching candidate key value in the
parent table.
For an ON DELETE or ON UPDATE that is not specified, the default action is always NO ACTION.
As the default, an ON DELETE NO ACTION or ON UPDATE NO ACTION clause that is specified
explicitly does not appear in SHOW CREATE TABLE output or in tables dumped with mysqldump.
RESTRICT, which is an equivalent non-default keyword, appears in SHOW CREATE TABLE output and
in tables dumped with mysqldump.
For NDB tables, ON UPDATE CASCADE is not supported where the reference is to the parent table's
primary key.
For NDB tables, ON DELETE CASCADE is not supported where the child table contains one or more
columns of any of the TEXT or BLOB types. (Bug #89511, Bug #27484882)
InnoDB performs cascading operations using a depth-first search algorithm on the records of the index
that corresponds to the foreign key constraint.
A foreign key constraint on a stored generated column cannot use CASCADE, SET NULL, or SET
DEFAULT as ON UPDATE referential actions, nor can it use SET NULL or SET DEFAULT as ON
DELETE referential actions.
A foreign key constraint on the base column of a stored generated column cannot use CASCADE, SET
NULL, or SET DEFAULT as ON UPDATE or ON DELETE referential actions.
Foreign Key Constraint Examples
This simple example relates parent and child tables through a single-column foreign key:
CREATE TABLE parent (
    id INT NOT NULL,
    PRIMARY KEY (id)
) ENGINE=INNODB;
CREATE TABLE child (
    id INT,
    parent_id INT,
    INDEX par_ind (parent_id),
    FOREIGN KEY (parent_id)
        REFERENCES parent(id)
        ON DELETE CASCADE
) ENGINE=INNODB;
MySQL 9.1 supports inline REFERENCE clauses as well as implicit parent table primary keys, so the
second CREATE TABLE statement can be rewritten as shown here:
CREATE TABLE child (
    id INT,
    parent_id INT NOT NULL REFERENCES parent ON DELETE CASCADE,
    INDEX par_ind (parent_id)
) ENGINE=INNODB;
This is a more complex example in which a product_order table has foreign keys for two other
tables. One foreign key references a two-column index in the product table. The other references a
single-column index in the customer table:
CREATE TABLE product (
    category INT NOT NULL, id INT NOT NULL,
    price DECIMAL,
    PRIMARY KEY(category, id)
)   ENGINE=INNODB;
CREATE TABLE customer (
    id INT NOT NULL,
    PRIMARY KEY (id)
)   ENGINE=INNODB;
CREATE TABLE product_order (
    no INT NOT NULL AUTO_INCREMENT,
    product_category INT NOT NULL,
    product_id INT NOT NULL,
    customer_id INT NOT NULL,
    PRIMARY KEY(no),
    INDEX (product_category, product_id),
    INDEX (customer_id),
    FOREIGN KEY (product_category, product_id)
      REFERENCES product(category, id)
      ON UPDATE CASCADE ON DELETE RESTRICT,
    FOREIGN KEY (customer_id)
      REFERENCES customer(id)
)   ENGINE=INNODB;
Adding Foreign Key Constraints
You can add a foreign key constraint to an existing table using the following ALTER TABLE syntax:
ALTER TABLE tbl_name
    ADD [CONSTRAINT [symbol]] FOREIGN KEY
    [index_name] (col_name, ...)
    REFERENCES tbl_name (col_name,...)
    [ON DELETE reference_option]
    [ON UPDATE reference_option]
The foreign key can be self referential (referring to the same table). When you add a foreign key
constraint to a table using ALTER TABLE, remember to first create an index on the column(s)
referenced by the foreign key.
Dropping Foreign Key Constraints
You can drop a foreign key constraint using the following ALTER TABLE syntax:
ALTER TABLE tbl_name DROP FOREIGN KEY fk_symbol;
If the FOREIGN KEY clause defined a CONSTRAINT name when you created the constraint, you can
refer to that name to drop the foreign key constraint. Otherwise, a constraint name was generated
internally, and you must use that value. To determine the foreign key constraint name, use SHOW
CREATE TABLE:
mysql> SHOW CREATE TABLE child\G
*************************** 1. row ***************************
       Table: child
Create Table: CREATE TABLE `child` (
  `id` int DEFAULT NULL,
  `parent_id` int NOT NULL,
  KEY `par_ind` (`parent_id`),
  CONSTRAINT `child_ibfk_1` FOREIGN KEY (`parent_id`)
  REFERENCES `parent` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
mysql> ALTER TABLE child DROP FOREIGN KEY `child_ibfk_1`;
Adding and dropping a foreign key in the same ALTER TABLE statement is supported for ALTER
TABLE ... ALGORITHM=INPLACE. It is not supported for ALTER TABLE ... ALGORITHM=COPY.
Foreign Key Checks
In MySQL, InnoDB and NDB tables support checking of foreign key constraints. Foreign key
checking is controlled by the foreign_key_checks variable, which is enabled by default.
Typically, you leave this variable enabled during normal operation to enforce referential integrity. The
foreign_key_checks variable has the same effect on NDB tables as it does for InnoDB tables.
The foreign_key_checks variable is dynamic and supports both global and session scopes. For
information about using system variables, see Section 7.1.9, “Using System Variables”.
Disabling foreign key checking is useful when:
• Dropping a table that is referenced by a foreign key constraint. A referenced table can only be
dropped after foreign_key_checks is disabled. When you drop a table, constraints defined on the
table are also dropped.
• Reloading tables in different order than required by their foreign key relationships. For example,
mysqldump produces correct definitions of tables in the dump file, including foreign key
constraints for child tables. To make it easier to reload dump files for tables with foreign key
relationships, mysqldump automatically includes a statement in the dump output that disables
foreign_key_checks. This enables you to import the tables in any order in case the dump file
contains tables that are not correctly ordered for foreign keys. Disabling foreign_key_checks
also speeds up the import operation by avoiding foreign key checks.
• Executing LOAD DATA operations, to avoid foreign key checking.
• Performing an ALTER TABLE operation on a table that has a foreign key relationship.
When foreign_key_checks is disabled, foreign key constraints are ignored, with the following
exceptions:
• Recreating a table that was previously dropped returns an error if the table definition does not
conform to the foreign key constraints that reference the table. The table must have the correct
column names and types. It must also have indexes on the referenced keys. If these requirements
are not satisfied, MySQL returns Error 1005 that refers to errno: 150 in the error message, which
means that a foreign key constraint was not correctly formed.
• Altering a table returns an error (errno: 150) if a foreign key definition is incorrectly formed for the
altered table.
• Dropping an index required by a foreign key constraint. The foreign key constraint must be removed
before dropping the index.
• Creating a foreign key constraint where a column references a nonmatching column type.
Disabling foreign_key_checks has these additional implications:
• It is permitted to drop a database that contains tables with foreign keys that are referenced by tables
outside the database.
• It is permitted to drop a table with foreign keys referenced by other tables.
• Enabling foreign_key_checks does not trigger a scan of table data, which means that rows
added to a table while foreign_key_checks is disabled are not checked for consistency when
foreign_key_checks is re-enabled.
Locking
MySQL extends metadata locks, as necessary, to tables that are related by a foreign key constraint.
Extending metadata locks prevents conflicting DML and DDL operations from executing concurrently
on related tables. This feature also enables updates to foreign key metadata when a parent table is
modified. In earlier MySQL releases, foreign key metadata, which is owned by the child table, could not
be updated safely.
If a table is locked explicitly with LOCK TABLES, any tables related by a foreign key constraint are
opened and locked implicitly. For foreign key checks, a shared read-only lock (LOCK TABLES READ) is
taken on related tables. For cascading updates, a shared-nothing write lock (LOCK TABLES WRITE) is
taken on related tables that are involved in the operation.
Foreign Key Definitions and Metadata
To view a foreign key definition, use SHOW CREATE TABLE:
mysql> SHOW CREATE TABLE child\G
*************************** 1. row ***************************
       Table: child
Create Table: CREATE TABLE `child` (
  `id` int DEFAULT NULL,
  `parent_id` int NOT NULL,
  KEY `par_ind` (`parent_id`),
  CONSTRAINT `child_ibfk_1` FOREIGN KEY (`parent_id`) 
  REFERENCES `parent` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
You can obtain information about foreign keys from the Information Schema KEY_COLUMN_USAGE
table. An example of a query against this table is shown here:
mysql> SELECT TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME, CONSTRAINT_NAME
       FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE
       WHERE REFERENCED_TABLE_SCHEMA IS NOT NULL;
+--------------+------------+-------------+-----------------+
| TABLE_SCHEMA | TABLE_NAME | COLUMN_NAME | CONSTRAINT_NAME |
+--------------+------------+-------------+-----------------+
| test         | child      | parent_id   | child_ibfk_1    |
+--------------+------------+-------------+-----------------+
You can obtain information specific to InnoDB foreign keys from the INNODB_FOREIGN and
INNODB_FOREIGN_COLS tables. Example queries are show here:
mysql> SELECT * FROM INFORMATION_SCHEMA.INNODB_FOREIGN \G
*************************** 1. row ***************************
      ID: test/child_ibfk_1
FOR_NAME: test/child
REF_NAME: test/parent
  N_COLS: 1
    TYPE: 1
mysql> SELECT * FROM INFORMATION_SCHEMA.INNODB_FOREIGN_COLS \G
*************************** 1. row ***************************
          ID: test/child_ibfk_1
FOR_COL_NAME: parent_id
REF_COL_NAME: id
         POS: 0
Foreign Key Errors
In the event of a foreign key error involving InnoDB tables (usually Error 150 in the MySQL Server),
information about the latest foreign key error can be obtained by checking SHOW ENGINE INNODB
STATUS output.
mysql> SHOW ENGINE INNODB STATUS\G
...
------------------------
LATEST FOREIGN KEY ERROR
------------------------
2018-04-12 14:57:24 0x7f97a9c91700 Transaction:
TRANSACTION 7717, ACTIVE 0 sec inserting
mysql tables in use 1, locked 1
4 lock struct(s), heap size 1136, 3 row lock(s), undo log entries 3
MySQL thread id 8, OS thread handle 140289365317376, query id 14 localhost root update
INSERT INTO child VALUES (NULL, 1), (NULL, 2), (NULL, 3), (NULL, 4), (NULL, 5), (NULL, 6)
Foreign key constraint fails for table `test`.`child`:
,
  CONSTRAINT `child_ibfk_1` FOREIGN KEY (`parent_id`) REFERENCES `parent` (`id`) ON DELETE
  CASCADE ON UPDATE CASCADE
Trying to add in child table, in index par_ind tuple:
DATA TUPLE: 2 fields;
 0: len 4; hex 80000003; asc     ;;
 1: len 4; hex 80000003; asc     ;;
But in parent table `test`.`parent`, in index PRIMARY,
the closest match we can find is record:
PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 80000004; asc     ;;
 1: len 6; hex 000000001e19; asc       ;;
 2: len 7; hex 81000001110137; asc       7;;
...
Warning
If a user has table-level privileges for all parent tables,
ER_NO_REFERENCED_ROW_2 and ER_ROW_IS_REFERENCED_2 error
messages for foreign key operations expose information about parent tables.
If a user does not have table-level privileges for all parent tables, more generic
error messages are displayed instead (ER_NO_REFERENCED_ROW and
ER_ROW_IS_REFERENCED).
An exception is that, for stored programs defined to execute with DEFINER
privileges, the user against which privileges are assessed is the user in the
program DEFINER clause, not the invoking user. If that user has table-level
parent table privileges, parent table information is still displayed. In this case,
it is the responsibility of the stored program creator to hide the information by
including appropriate condition handlers.
15.1.20.6 CHECK Constraints
CREATE TABLE permits the core features of table and column CHECK constraints, for all storage
engines. CREATE TABLE permits the following CHECK constraint syntax, for both table constraints and
column constraints:
[CONSTRAINT [symbol]] CHECK (expr) [[NOT] ENFORCED]
The optional symbol specifies a name for the constraint. If omitted, MySQL generates a name from
the table name, a literal _chk_, and an ordinal number (1, 2, 3, ...). Constraint names have a maximum
length of 64 characters. They are case-sensitive, but not accent-sensitive.
expr specifies the constraint condition as a boolean expression that must evaluate to TRUE or
UNKNOWN (for NULL values) for each row of the table. If the condition evaluates to FALSE, it fails and
a constraint violation occurs. The effect of a violation depends on the statement being executed, as
described later in this section.
The optional enforcement clause indicates whether the constraint is enforced:
• If omitted or specified as ENFORCED, the constraint is created and enforced.
• If specified as NOT ENFORCED, the constraint is created but not enforced.
A CHECK constraint is specified as either a table constraint or column constraint:
• A table constraint does not appear within a column definition and can refer to any table column or
columns. Forward references are permitted to columns appearing later in the table definition.
• A column constraint appears within a column definition and can refer only to that column.
Consider this table definition:
CREATE TABLE t1
(
  CHECK (c1 <> c2),
  c1 INT CHECK (c1 > 10),
  c2 INT CONSTRAINT c2_positive CHECK (c2 > 0),
  c3 INT CHECK (c3 < 100),
  CONSTRAINT c1_nonzero CHECK (c1 <> 0),
  CHECK (c1 > c3)
);
The definition includes table constraints and column constraints, in named and unnamed formats:
• The first constraint is a table constraint: It occurs outside any column definition, so it can (and does)
refer to multiple table columns. This constraint contains forward references to columns not defined
yet. No constraint name is specified, so MySQL generates a name.
• The next three constraints are column constraints: Each occurs within a column definition, and
thus can refer only to the column being defined. One of the constraints is named explicitly. MySQL
generates a name for each of the other two.
• The last two constraints are table constraints. One of them is named explicitly. MySQL generates a
name for the other one.
As mentioned, MySQL generates a name for any CHECK constraint specified without one. To see the
names generated for the preceding table definition, use SHOW CREATE TABLE:
mysql> SHOW CREATE TABLE t1\G
*************************** 1. row ***************************
       Table: t1
Create Table: CREATE TABLE `t1` (
  `c1` int(11) DEFAULT NULL,
  `c2` int(11) DEFAULT NULL,
  `c3` int(11) DEFAULT NULL,
  CONSTRAINT `c1_nonzero` CHECK ((`c1` <> 0)),
  CONSTRAINT `c2_positive` CHECK ((`c2` > 0)),
  CONSTRAINT `t1_chk_1` CHECK ((`c1` <> `c2`)),
  CONSTRAINT `t1_chk_2` CHECK ((`c1` > 10)),
  CONSTRAINT `t1_chk_3` CHECK ((`c3` < 100)),
  CONSTRAINT `t1_chk_4` CHECK ((`c1` > `c3`))
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
The SQL standard specifies that all types of constraints (primary key, unique index, foreign key, check)
belong to the same namespace. In MySQL, each constraint type has its own namespace per schema
(database). Consequently, CHECK constraint names must be unique per schema; no two tables in
the same schema can share a CHECK constraint name. (Exception: A TEMPORARY table hides a
non-TEMPORARY table of the same name, so it can have the same CHECK constraint names as well.)
Beginning generated constraint names with the table name helps ensure schema uniqueness because
table names also must be unique within the schema.
CHECK condition expressions must adhere to the following rules. An error occurs if an expression
contains disallowed constructs.
• Nongenerated and generated columns are permitted, except columns with the AUTO_INCREMENT
attribute and columns in other tables.
• Literals, deterministic built-in functions, and operators are permitted. A function is deterministic
if, given the same data in tables, multiple invocations produce the same result, independently
of the connected user. Examples of functions that are nondeterministic and fail this definition:
CONNECTION_ID(), CURRENT_USER(), NOW().
• Stored functions and loadable functions are not permitted.
• Stored procedure and function parameters are not permitted.
• Variables (system variables, user-defined variables, and stored program local variables) are not
permitted.
• Subqueries are not permitted.
Foreign key referential actions (ON UPDATE, ON DELETE) are prohibited on columns used in CHECK
constraints. Likewise, CHECK constraints are prohibited on columns used in foreign key referential
actions.
CHECK constraints are evaluated for INSERT, UPDATE, REPLACE, LOAD DATA, and LOAD XML
statements and an error occurs if a constraint evaluates to FALSE. If an error occurs, handling of
changes already applied differs for transactional and nontransactional storage engines, and also
depends on whether strict SQL mode is in effect, as described in Strict SQL Mode.
CHECK constraints are evaluated for INSERT IGNORE, UPDATE IGNORE, LOAD DATA ... IGNORE,
and LOAD XML ... IGNORE statements and a warning occurs if a constraint evaluates to FALSE.
The insert or update for any offending row is skipped.
If the constraint expression evaluates to a data type that differs from the declared column type, implicit
coercion to the declared type occurs according to the usual MySQL type-conversion rules. See
Section 14.3, “Type Conversion in Expression Evaluation”. If type conversion fails or results in a loss of
precision, an error occurs.
Note
Constraint expression evaluation uses the SQL mode in effect at evaluation
time. If any component of the expression depends on the SQL mode, different
results may occur for different uses of the table unless the SQL mode is the
same during all uses.
The Information Schema CHECK_CONSTRAINTS table provides information about CHECK constraints
defined on tables. See Section 28.3.5, “The INFORMATION_SCHEMA CHECK_CONSTRAINTS
Table”.
15.1.20.7 Silent Column Specification Changes
In some cases, MySQL silently changes column specifications from those given in a CREATE TABLE or
ALTER TABLE statement. These might be changes to a data type, to attributes associated with a data
type, or to an index specification.
All changes are subject to the internal row-size limit of 65,535 bytes, which may cause some attempts
at data type changes to fail. See Section 10.4.7, “Limits on Table Column Count and Row Size”.
• Columns that are part of a PRIMARY KEY are made NOT NULL even if not declared that way.
• Trailing spaces are automatically deleted from ENUM and SET member values when the table is
created.
• MySQL maps certain data types used by other SQL database vendors to MySQL types. See
Section 13.9, “Using Data Types from Other Database Engines”.
• If you include a USING clause to specify an index type that is not permitted for a given storage
engine, but there is another index type available that the engine can use without affecting query
results, the engine uses the available type.
• If strict SQL mode is not enabled, a VARCHAR column with a length specification greater than 65535
is converted to TEXT, and a VARBINARY column with a length specification greater than 65535 is
converted to BLOB. Otherwise, an error occurs in either of these cases.
• Specifying the CHARACTER SET binary attribute for a character data type causes the column
to be created as the corresponding binary data type: CHAR becomes BINARY, VARCHAR becomes
VARBINARY, and TEXT becomes BLOB. For the ENUM and SET data types, this does not occur; they
are created as declared. Suppose that you specify a table using this definition:
CREATE TABLE t
(
  c1 VARCHAR(10) CHARACTER SET binary,
  c2 TEXT CHARACTER SET binary,
  c3 ENUM('a','b','c') CHARACTER SET binary
);
The resulting table has this definition:
CREATE TABLE t
(
  c1 VARBINARY(10),
  c2 BLOB,
  c3 ENUM('a','b','c') CHARACTER SET binary
);
To see whether MySQL used a data type other than the one you specified, issue a DESCRIBE or SHOW
CREATE TABLE statement after creating or altering the table.
Certain other data type changes can occur if you compress a table using myisampack. See
Section 18.2.3.3, “Compressed Table Characteristics”.
15.1.20.8 CREATE TABLE and Generated Columns
CREATE TABLE supports the specification of generated columns. Values of a generated column are
computed from an expression included in the column definition.
Generated columns are also supported by the NDB storage engine.
The following simple example shows a table that stores the lengths of the sides of right triangles in the
sidea and sideb columns, and computes the length of the hypotenuse in sidec (the square root of
the sums of the squares of the other sides):
CREATE TABLE triangle (
  sidea DOUBLE,
  sideb DOUBLE,
  sidec DOUBLE AS (SQRT(sidea * sidea + sideb * sideb))
);
INSERT INTO triangle (sidea, sideb) VALUES(1,1),(3,4),(6,8);
Selecting from the table yields this result:
mysql> SELECT * FROM triangle;
+-------+-------+--------------------+
| sidea | sideb | sidec              |
+-------+-------+--------------------+
|     1 |     1 | 1.4142135623730951 |
|     3 |     4 |                  5 |
|     6 |     8 |                 10 |
+-------+-------+--------------------+
Any application that uses the triangle table has access to the hypotenuse values without having to
specify the expression that calculates them.
Generated column definitions have this syntax:
col_name data_type [GENERATED ALWAYS] AS (expr)
  [VIRTUAL | STORED] [NOT NULL | NULL]
  [UNIQUE [KEY]] [[PRIMARY] KEY]
  [COMMENT 'string']
AS (expr) indicates that the column is generated and defines the expression used to compute
column values. AS may be preceded by GENERATED ALWAYS to make the generated nature of the
column more explicit. Constructs that are permitted or prohibited in the expression are discussed later.
The VIRTUAL or STORED keyword indicates how column values are stored, which has implications for
column use:
• VIRTUAL: Column values are not stored, but are evaluated when rows are read, immediately after
any BEFORE triggers. A virtual column takes no storage.
InnoDB supports secondary indexes on virtual columns. See Section 15.1.20.9, “Secondary Indexes
and Generated Columns”.
• STORED: Column values are evaluated and stored when rows are inserted or updated. A stored
column does require storage space and can be indexed.
The default is VIRTUAL if neither keyword is specified.
It is permitted to mix VIRTUAL and STORED columns within a table.
Other attributes may be given to indicate whether the column is indexed or can be NULL, or provide a
comment.
Generated column expressions must adhere to the following rules. An error occurs if an expression
contains disallowed constructs.
• Literals, deterministic built-in functions, and operators are permitted. A function is deterministic
if, given the same data in tables, multiple invocations produce the same result, independently
of the connected user. Examples of functions that are nondeterministic and fail this definition:
CONNECTION_ID(), CURRENT_USER(), NOW().
• Stored functions and loadable functions are not permitted.
• Stored procedure and function parameters are not permitted.
• Variables (system variables, user-defined variables, and stored program local variables) are not
permitted.
• Subqueries are not permitted.
• A generated column definition can refer to other generated columns, but only those occurring earlier
in the table definition. A generated column definition can refer to any base (nongenerated) column in
the table whether its definition occurs earlier or later.
• The AUTO_INCREMENT attribute cannot be used in a generated column definition.
• An AUTO_INCREMENT column cannot be used as a base column in a generated column definition.
• If expression evaluation causes truncation or provides incorrect input to a function, the CREATE
TABLE statement terminates with an error and the DDL operation is rejected.
If the expression evaluates to a data type that differs from the declared column type, implicit coercion to
the declared type occurs according to the usual MySQL type-conversion rules. See Section 14.3, “Type
Conversion in Expression Evaluation”.
If a generated column uses the TIMESTAMP data type, the setting for
explicit_defaults_for_timestamp is ignored. In such cases, if this variable is disabled
then NULL is not converted to CURRENT_TIMESTAMP. If the column is also declared as NOT NULL,
attempting to insert NULL is explicitly rejected with ER_BAD_NULL_ERROR.
Note
Expression evaluation uses the SQL mode in effect at evaluation time. If any
component of the expression depends on the SQL mode, different results may
occur for different uses of the table unless the SQL mode is the same during all
uses.
For CREATE TABLE ... LIKE, the destination table preserves generated column information from
the original table.
For CREATE TABLE ... SELECT, the destination table does not preserve information about whether
columns in the selected-from table are generated columns. The SELECT part of the statement cannot
assign values to generated columns in the destination table.
Partitioning by generated columns is permitted. See Table Partitioning.
A foreign key constraint on a stored generated column cannot use CASCADE, SET NULL, or SET
DEFAULT as ON UPDATE referential actions, nor can it use SET NULL or SET DEFAULT as ON
DELETE referential actions.
A foreign key constraint on the base column of a stored generated column cannot use CASCADE, SET
NULL, or SET DEFAULT as ON UPDATE or ON DELETE referential actions.
A foreign key constraint cannot reference a virtual generated column.
Triggers cannot use NEW.col_name or use OLD.col_name to refer to generated columns.
For INSERT, REPLACE, and UPDATE, if a generated column is inserted into, replaced, or updated
explicitly, the only permitted value is DEFAULT.
A generated column in a view is considered updatable because it is possible to assign to it. However, if
such a column is updated explicitly, the only permitted value is DEFAULT.
Generated columns have several use cases, such as these:
• Virtual generated columns can be used as a way to simplify and unify queries. A complicated
condition can be defined as a generated column and referred to from multiple queries on the table to
ensure that all of them use exactly the same condition.
• Stored generated columns can be used as a materialized cache for complicated conditions that are
costly to calculate on the fly.
• Generated columns can simulate functional indexes: Use a generated column to define a functional
expression and index it. This can be useful for working with columns of types that cannot be indexed
directly, such as JSON columns; see Indexing a Generated Column to Provide a JSON Column
Index, for a detailed example.
For stored generated columns, the disadvantage of this approach is that values are stored twice;
once as the value of the generated column and once in the index.
• If a generated column is indexed, the optimizer recognizes query expressions that match the column
definition and uses indexes from the column as appropriate during query execution, even if a query
does not refer to the column directly by name. For details, see Section 10.3.11, “Optimizer Use of
Generated Column Indexes”.
Example:
Suppose that a table t1 contains first_name and last_name columns and that applications
frequently construct the full name using an expression like this:
SELECT CONCAT(first_name,' ',last_name) AS full_name FROM t1;
One way to avoid writing out the expression is to create a view v1 on t1, which simplifies applications
by enabling them to select full_name directly without using an expression:
CREATE VIEW v1 AS
SELECT *, CONCAT(first_name,' ',last_name) AS full_name FROM t1;
SELECT full_name FROM v1;
A generated column also enables applications to select full_name directly without the need to define
a view:
CREATE TABLE t1 (
  first_name VARCHAR(10),
  last_name VARCHAR(10),
  full_name VARCHAR(255) AS (CONCAT(first_name,' ',last_name))
);
SELECT full_name FROM t1;
15.1.20.9 Secondary Indexes and Generated Columns
InnoDB supports secondary indexes on virtual generated columns. Other index types are not
supported. A secondary index defined on a virtual column is sometimes referred to as a “virtual index”.
A secondary index may be created on one or more virtual columns or on a combination of virtual
columns and regular columns or stored generated columns. Secondary indexes that include virtual
columns may be defined as UNIQUE.
When a secondary index is created on a virtual generated column, generated column values are
materialized in the records of the index. If the index is a covering index (one that includes all the
columns retrieved by a query), generated column values are retrieved from materialized values in the
index structure instead of computed “on the fly”.
There are additional write costs to consider when using a secondary index on a virtual column due to
computation performed when materializing virtual column values in secondary index records during
INSERT and UPDATE operations. Even with additional write costs, secondary indexes on virtual
columns may be preferable to generated stored columns, which are materialized in the clustered index,
resulting in larger tables that require more disk space and memory. If a secondary index is not defined
on a virtual column, there are additional costs for reads, as virtual column values must be computed
each time the column's row is examined.
Values of an indexed virtual column are MVCC-logged to avoid unnecessary recomputation of
generated column values during rollback or during a purge operation. The data length of logged values
is limited by the index key limit of 767 bytes for COMPACT and REDUNDANT row formats, and 3072 bytes
for DYNAMIC and COMPRESSED row formats.
Adding or dropping a secondary index on a virtual column is an in-place operation.
Indexing a Generated Column to Provide a JSON Column Index
As noted elsewhere, JSON columns cannot be indexed directly. To create an index that references
such a column indirectly, you can define a generated column that extracts the information that should
be indexed, then create an index on the generated column, as shown in this example:
mysql> CREATE TABLE jemp (
    ->     c JSON,
    ->     g INT GENERATED ALWAYS AS (c->"$.id"),
    ->     INDEX i (g)
    -> );
Query OK, 0 rows affected (0.28 sec)
mysql> INSERT INTO jemp (c) VALUES
     >   ('{"id": "1", "name": "Fred"}'), ('{"id": "2", "name": "Wilma"}'),
     >   ('{"id": "3", "name": "Barney"}'), ('{"id": "4", "name": "Betty"}');
Query OK, 4 rows affected (0.04 sec)
Records: 4  Duplicates: 0  Warnings: 0
mysql> SELECT c->>"$.name" AS name
     >     FROM jemp WHERE g > 2;
+--------+
| name   |
+--------+
| Barney |
| Betty  |
+--------+
2 rows in set (0.00 sec)
mysql> EXPLAIN SELECT c->>"$.name" AS name
     >    FROM jemp WHERE g > 2\G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: jemp
   partitions: NULL
         type: range
possible_keys: i
          key: i
      key_len: 5
          ref: NULL
         rows: 2
     filtered: 100.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)
mysql> SHOW WARNINGS\G
*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: /* select#1 */ select json_unquote(json_extract(`test`.`jemp`.`c`,'$.name'))
AS `name` from `test`.`jemp` where (`test`.`jemp`.`g` > 2)
1 row in set (0.00 sec)
(We have wrapped the output from the last statement in this example to fit the viewing area.)
When you use EXPLAIN on a SELECT or other SQL statement containing one or more expressions
that use the -> or ->> operator, these expressions are translated into their equivalents using
JSON_EXTRACT() and (if needed) JSON_UNQUOTE() instead, as shown here in the output from SHOW
WARNINGS immediately following this EXPLAIN statement:
mysql> EXPLAIN SELECT c->>"$.name"
     > FROM jemp WHERE g > 2 ORDER BY c->"$.name"\G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: jemp
   partitions: NULL
         type: range
possible_keys: i
          key: i
      key_len: 5
          ref: NULL
         rows: 2
     filtered: 100.00
        Extra: Using where; Using filesort
1 row in set, 1 warning (0.00 sec)
mysql> SHOW WARNINGS\G
*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: /* select#1 */ select json_unquote(json_extract(`test`.`jemp`.`c`,'$.name')) AS
`c->>"$.name"` from `test`.`jemp` where (`test`.`jemp`.`g` > 2) order by
json_extract(`test`.`jemp`.`c`,'$.name')
1 row in set (0.00 sec)
See the descriptions of the -> and ->> operators, as well as those of the JSON_EXTRACT() and
JSON_UNQUOTE() functions, for additional information and examples.
This technique also can be used to provide indexes that indirectly reference columns of other types that
cannot be indexed directly, such as GEOMETRY columns.
It is also possible to create an index on a JSON column using the JSON_VALUE() function with an
expression that can be used to optimize queries employing the expression. See the description of that
function for more information and examples.
JSON columns and indirect indexing in NDB Cluster
    It is also possible to use indirect indexing of JSON columns in MySQL NDB Cluster, subject to the
following conditions:
1. NDB handles a JSON column value internally as a BLOB. This means that any NDB table having one
or more JSON columns must have a primary key, else it cannot be recorded in the binary log.
2. The NDB storage engine does not support indexing of virtual columns. Since the default for
generated columns is VIRTUAL, you must specify explicitly the generated column to which to apply
the indirect index as STORED.
The CREATE TABLE statement used to create the table jempn shown here is a version of the jemp
table shown previously, with modifications making it compatible with NDB:
CREATE TABLE jempn (
  a BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
  c JSON DEFAULT NULL,
  g INT GENERATED ALWAYS AS (c->"$.id") STORED,
  INDEX i (g)
) ENGINE=NDB;
We can populate this table using the following INSERT statement:
INSERT INTO jempn (c) VALUES
  ('{"id": "1", "name": "Fred"}'),
  ('{"id": "2", "name": "Wilma"}'),
  ('{"id": "3", "name": "Barney"}'),
  ('{"id": "4", "name": "Betty"}');
Now NDB can use index i, as shown here:
mysql> EXPLAIN SELECT c->>"$.name" AS name
    ->           FROM jempn WHERE g > 2\G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: jempn
   partitions: p0,p1,p2,p3
         type: range
possible_keys: i
          key: i
      key_len: 5
          ref: NULL
         rows: 3
     filtered: 100.00
        Extra: Using pushed condition (`test`.`jempn`.`g` > 2)
1 row in set, 1 warning (0.01 sec)
mysql> SHOW WARNINGS\G
*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: /* select#1 */ select
json_unquote(json_extract(`test`.`jempn`.`c`,'$.name')) AS `name` from
`test`.`jempn` where (`test`.`jempn`.`g` > 2)   
1 row in set (0.00 sec)
You should keep in mind that a stored generated column, as well as any index on such a column, uses
DataMemory.
15.1.20.10 Invisible Columns
MySQL 9.1 supports invisible columns. An invisible column is normally hidden to queries, but can be
accessed if explicitly referenced.
As an illustration of when invisible columns may be useful, suppose that an application uses SELECT
* queries to access a table, and must continue to work without modification even if the table is altered
to add a new column that the application does not expect to be there. In a SELECT * query, the *
evaluates to all table columns, except those that are invisible, so the solution is to add the new column
as an invisible column. The column remains “hidden” from SELECT * queries, and the application
continues to work as previously. A newer version of the application can refer to the invisible column if
necessary by explicitly referencing it.
The following sections detail how MySQL treats invisible columns.
• DDL Statements and Invisible Columns
• DML Statements and Invisible Columns
• Invisible Column Metadata
• The Binary Log and Invisible Columns
DDL Statements and Invisible Columns
Columns are visible by default. To explicitly specify visibility for a new column, use a VISIBLE or
INVISIBLE keyword as part of the column definition for CREATE TABLE or ALTER TABLE:
CREATE TABLE t1 (
  i INT,
  j DATE INVISIBLE
) ENGINE = InnoDB;
ALTER TABLE t1 ADD COLUMN k INT INVISIBLE;
To alter the visibility of an existing column, use a VISIBLE or INVISIBLE keyword with one of the
ALTER TABLE column-modification clauses:
ALTER TABLE t1 CHANGE COLUMN j j DATE VISIBLE;
ALTER TABLE t1 MODIFY COLUMN j DATE INVISIBLE;
ALTER TABLE t1 ALTER COLUMN j SET VISIBLE;
A table must have at least one visible column. Attempting to make all columns invisible produces an
error.
Invisible columns support the usual column attributes: NULL, NOT NULL, AUTO_INCREMENT, and so
forth.
Generated columns can be invisible.
Index definitions can name invisible columns, including definitions for PRIMARY KEY and UNIQUE
indexes. Although a table must have at least one visible column, an index definition need not have any
visible columns.
An invisible column dropped from a table is dropped in the usual way from any index definition that
names the column.
Foreign key constraints can be defined on invisible columns, and foreign key constraints can reference
invisible columns.
CHECK constraints can be defined on invisible columns. For new or modified rows, violation of a CHECK
constraint on an invisible column produces an error.
CREATE TABLE ... LIKE includes invisible columns, and they are invisible in the new table.
CREATE TABLE ... SELECT does not include invisible columns, unless they are explicitly referenced
in the SELECT part. However, even if explicitly referenced, a column that is invisible in the existing table
is visible in the new table:
mysql> CREATE TABLE t1 (col1 INT, col2 INT INVISIBLE);
mysql> CREATE TABLE t2 AS SELECT col1, col2 FROM t1;
mysql> SHOW CREATE TABLE t2\G
*************************** 1. row ***************************
       Table: t2
Create Table: CREATE TABLE `t2` (
  `col1` int DEFAULT NULL,
  `col2` int DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
If invisibility should be preserved, provide a definition for the invisible column in the CREATE TABLE
part of the CREATE TABLE ... SELECT statement:
mysql> CREATE TABLE t1 (col1 INT, col2 INT INVISIBLE);
mysql> CREATE TABLE t2 (col2 INT INVISIBLE) AS SELECT col1, col2 FROM t1;
mysql> SHOW CREATE TABLE t2\G
*************************** 1. row ***************************
       Table: t2
Create Table: CREATE TABLE `t2` (
  `col1` int DEFAULT NULL,
  `col2` int DEFAULT NULL /*!80023 INVISIBLE */
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
Views can refer to invisible columns by explicitly referencing them in the SELECT statement that
defines the view. Changing a column's visibility subsequent to defining a view that references the
column does not change view behavior.
DML Statements and Invisible Columns
For SELECT statements, an invisible column is not part of the result set unless explicitly referenced
in the select list. In a select list, the * and tbl_name.* shorthands do not include invisible columns.
Natural joins do not include invisible columns.
Consider the following statement sequence:
mysql> CREATE TABLE t1 (col1 INT, col2 INT INVISIBLE);
mysql> INSERT INTO t1 (col1, col2) VALUES(1, 2), (3, 4);
mysql> SELECT * FROM t1;
+------+
| col1 |
+------+
|    1 |
|    3 |
+------+
mysql> SELECT col1, col2 FROM t1;
+------+------+
| col1 | col2 |
+------+------+
|    1 |    2 |
|    3 |    4 |
+------+------+
The first SELECT does not reference the invisible column col2 in the select list (because * does not
include invisible columns), so col2 does not appear in the statement result. The second SELECT
explicitly references col2, so the column appears in the result.
The statement TABLE t1 produces the same output as the first SELECT statement. Since there is no
way to specify columns in a TABLE statement, TABLE never displays invisible columns.
For statements that create new rows, an invisible column is assigned its implicit default value unless
explicitly referenced and assigned a value. For information about implicit defaults, see Implicit Default
Handling.
For INSERT (and REPLACE, for non-replaced rows), implicit default assignment occurs with a missing
column list, an empty column list, or a nonempty column list that does not include the invisible column:
CREATE TABLE t1 (col1 INT, col2 INT INVISIBLE);
INSERT INTO t1 VALUES(...);
INSERT INTO t1 () VALUES(...);
INSERT INTO t1 (col1) VALUES(...);
For the first two INSERT statements, the VALUES() list must provide a value for each visible column
and no invisible column. For the third INSERT statement, the VALUES() list must provide the same
number of values as the number of named columns; the same is true when you use VALUES ROW()
rather than VALUES().
For LOAD DATA and LOAD XML, implicit default assignment occurs with a missing column list or a
nonempty column list that does not include the invisible column. Input rows should not include a value
for the invisible column.
To assign a value other than the implicit default for the preceding statements, explicitly name the
invisible column in the column list and provide a value for it.
INSERT INTO ... SELECT * and REPLACE INTO ... SELECT * do not include invisible
columns because * does not include invisible columns. Implicit default assignment occurs as described
previously.
For statements that insert or ignore new rows, or that replace or modify existing rows, based on values
in a PRIMARY KEY or UNIQUE index, MySQL treats invisible columns the same as visible columns:
Invisible columns participate in key value comparisons. Specifically, if a new row has the same value
as an existing row for a unique key value, these behaviors occur whether the index columns are visible
or invisible:
• With the IGNORE modifier, INSERT, LOAD DATA, and LOAD XML ignore the new row.
• REPLACE replaces the existing row with the new row. With the REPLACE modifier, LOAD DATA and
LOAD XML do the same.
• INSERT ... ON DUPLICATE KEY UPDATE updates the existing row.
To update invisible columns for UPDATE statements, name them and assign a value, just as for visible
columns.
Invisible Column Metadata
Information about whether a column is visible or invisible is available from the EXTRA column of the
Information Schema COLUMNS table or SHOW COLUMNS output. For example:
mysql> SELECT TABLE_NAME, COLUMN_NAME, EXTRA
       FROM INFORMATION_SCHEMA.COLUMNS
       WHERE TABLE_SCHEMA = 'test' AND TABLE_NAME = 't1';
+------------+-------------+-----------+
| TABLE_NAME | COLUMN_NAME | EXTRA     |
+------------+-------------+-----------+
| t1         | i           |           |
| t1         | j           |           |
| t1         | k           | INVISIBLE |
+------------+-------------+-----------+
Columns are visible by default, so in that case, EXTRA displays no visibility information. For invisible
columns, EXTRA displays INVISIBLE.
SHOW CREATE TABLE displays invisible columns in the table definition, with the INVISIBLE keyword
in a version-specific comment:
mysql> SHOW CREATE TABLE t1\G
*************************** 1. row ***************************
       Table: t1
Create Table: CREATE TABLE `t1` (
  `i` int DEFAULT NULL,
  `j` int DEFAULT NULL,
  `k` int DEFAULT NULL /*!80023 INVISIBLE */
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
mysqldump uses SHOW CREATE TABLE, so they include invisible columns in dumped table
definitions. They also include invisible column values in dumped data.
Reloading a dump file into an older version of MySQL that does not support invisible columns causes
the version-specific comment to be ignored, which creates any invisible columns as visible.
The Binary Log and Invisible Columns
MySQL treats invisible columns as follows with respect to events in the binary log:
• Table-creation events include the INVISIBLE attribute for invisible columns.
• Invisible columns are treated like visible columns in row events. They are included if needed
according to the binlog_row_image system variable setting.
• When row events are applied, invisible columns are treated like visible columns in row events.
• Invisible columns are treated like visible columns when computing writesets. In particular, writesets
include indexes defined on invisible columns.
• The mysqlbinlog command includes visibility in column metadata.
15.1.20.11 Generated Invisible Primary Keys
MySQL 9.1 supports generated invisible primary keys for any InnoDB table that is created without an
explicit primary key. When the sql_generate_invisible_primary_key server system variable is
set to ON, the MySQL server automatically adds a generated invisible primary key (GIPK) to any such
table. This setting has no effect on tables created using any other storage engine than InnoDB.
By default, the value of sql_generate_invisible_primary_key is OFF, meaning that the
automatic addition of GIPKs is disabled. To illustrate how this affects table creation, we begin by
creating two identical tables, neither having a primary key, the only difference being that the first (table
auto_0) is created with sql_generate_invisible_primary_key set to OFF, and the second
(auto_1) after setting it to ON, as shown here:
mysql> SELECT @@sql_generate_invisible_primary_key;
+--------------------------------------+
| @@sql_generate_invisible_primary_key |
+--------------------------------------+
|                                    0 |
+--------------------------------------+
1 row in set (0.00 sec)
mysql> CREATE TABLE auto_0 (c1 VARCHAR(50), c2 INT);
Query OK, 0 rows affected (0.02 sec)
mysql> SET sql_generate_invisible_primary_key=ON;
Query OK, 0 rows affected (0.00 sec)
mysql> SELECT @@sql_generate_invisible_primary_key;
+--------------------------------------+
| @@sql_generate_invisible_primary_key |
+--------------------------------------+
|                                    1 |
+--------------------------------------+
1 row in set (0.00 sec)
mysql> CREATE TABLE auto_1 (c1 VARCHAR(50), c2 INT);
Query OK, 0 rows affected (0.04 sec)
Compare the output of these SHOW CREATE TABLE statements to see the difference in how the tables
were actually created:
mysql> SHOW CREATE TABLE auto_0\G
*************************** 1. row ***************************
       Table: auto_0
Create Table: CREATE TABLE `auto_0` (
  `c1` varchar(50) DEFAULT NULL,
  `c2` int DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
1 row in set (0.00 sec)
mysql> SHOW CREATE TABLE auto_1\G
*************************** 1. row ***************************
       Table: auto_1
Create Table: CREATE TABLE `auto_1` (
  `my_row_id` bigint unsigned NOT NULL AUTO_INCREMENT /*!80023 INVISIBLE */,
  `c1` varchar(50) DEFAULT NULL,
  `c2` int DEFAULT NULL,
  PRIMARY KEY (`my_row_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
1 row in set (0.00 sec)
Since auto_1 had no primary key specified by the CREATE TABLE statement used to
create it, setting sql_generate_invisible_primary_key = ON causes MySQL to add
both the invisible column my_row_id to this table and a primary key on that column. Since
sql_generate_invisible_primary_key was OFF at the time that auto_0 was created, no such
additions were performed on that table.
When a primary key is added to a table by the server, the column and key name is always my_row_id.
For this reason, when enabling generated invisible primary keys in this way, you cannot create a table
having a column named my_row_id unless the table creation statement also specifies an explicit
primary key. (You are not required to name the column or key my_row_id in such cases.)
my_row_id is an invisible column, which means it is not shown in the output of SELECT * or TABLE;
the column must be selected explicitly by name. See Section 15.1.20.10, “Invisible Columns”.
When GIPKs are enabled, a generated primary key cannot be altered other than to switch it between
VISIBLE and INVISIBLE. To make the generated invisible primary key on auto_1 visible, execute
this ALTER TABLE statement:
mysql> ALTER TABLE auto_1 ALTER COLUMN my_row_id SET VISIBLE;
Query OK, 0 rows affected (0.02 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql> SHOW CREATE TABLE auto_1\G
*************************** 1. row ***************************
       Table: auto_1
Create Table: CREATE TABLE `auto_1` (
  `my_row_id` bigint unsigned NOT NULL AUTO_INCREMENT,
  `c1` varchar(50) DEFAULT NULL,
  `c2` int DEFAULT NULL,
  PRIMARY KEY (`my_row_id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
1 row in set (0.01 sec)
To make this generated primary key invisible again, issue ALTER TABLE auto_1 ALTER COLUMN
my_row_id SET INVISIBLE.
A generated invisible primary key is always invisible by default.
Whenever GIPKs are enabled, you cannot drop a generated primary key if either of the following 2
conditions would result:
• The table is left with no primary key.
• The primary key is dropped, but not the primary key column.
The effects of sql_generate_invisible_primary_key apply to tables using the InnoDB storage
engine only. You can use an ALTER TABLE statement to change the storage engine used by a table
that has a generated invisible primary key; in this case, the primary key and column remain in place,
but the table and key no longer receive any special treatment.
By default, GIPKs are shown in the output of SHOW CREATE TABLE, SHOW COLUMNS, and
SHOW INDEX, and are visible in the Information Schema COLUMNS and STATISTICS tables. You
can cause generated invisible primary keys to be hidden instead in such cases by setting the
show_gipk_in_create_table_and_information_schema system variable to OFF. By default,
this variable is ON, as shown here:
mysql> SELECT @@show_gipk_in_create_table_and_information_schema;
+----------------------------------------------------+
| @@show_gipk_in_create_table_and_information_schema |
+----------------------------------------------------+
|                                                  1 |
+----------------------------------------------------+
1 row in set (0.00 sec)
As can be seen from the following query against the COLUMNS table, my_row_id is visible among the
columns of auto_1:
mysql> SELECT COLUMN_NAME, ORDINAL_POSITION, DATA_TYPE, COLUMN_KEY
    -> FROM INFORMATION_SCHEMA.COLUMNS
    -> WHERE TABLE_NAME = "auto_1";
+-------------+------------------+-----------+------------+
| COLUMN_NAME | ORDINAL_POSITION | DATA_TYPE | COLUMN_KEY |
+-------------+------------------+-----------+------------+
| my_row_id   |                1 | bigint    | PRI        |
| c1          |                2 | varchar   |            |
| c2          |                3 | int       |            |
+-------------+------------------+-----------+------------+
3 rows in set (0.01 sec)
After show_gipk_in_create_table_and_information_schema is set to OFF, my_row_id can
no longer be seen in the COLUMNS table, as shown here:
mysql> SET show_gipk_in_create_table_and_information_schema = OFF;
Query OK, 0 rows affected (0.00 sec)
mysql> SELECT @@show_gipk_in_create_table_and_information_schema;
+----------------------------------------------------+
| @@show_gipk_in_create_table_and_information_schema |
+----------------------------------------------------+
|                                                  0 |
+----------------------------------------------------+
1 row in set (0.00 sec)
mysql> SELECT COLUMN_NAME, ORDINAL_POSITION, DATA_TYPE, COLUMN_KEY
    -> FROM INFORMATION_SCHEMA.COLUMNS
    -> WHERE TABLE_NAME = "auto_1";
+-------------+------------------+-----------+------------+
| COLUMN_NAME | ORDINAL_POSITION | DATA_TYPE | COLUMN_KEY |
+-------------+------------------+-----------+------------+
| c1          |                2 | varchar   |            |
| c2          |                3 | int       |            |
+-------------+------------------+-----------+------------+
2 rows in set (0.00 sec)
The setting for sql_generate_invisible_primary_key is not replicated, and is ignored by
replication applier threads. This means that the setting of this variable on the source has no effect on
the replica. You can cause the replica to add a GIPK for tables replicated without primary keys on a
given replication channel using REQUIRE_TABLE_PRIMARY_KEY_CHECK = GENERATE as part of a
CHANGE REPLICATION SOURCE TO statement.
GIPKs work with row-based replication of CREATE TABLE ... SELECT; the information written to
the binary log for this statement in such cases includes the GIPK definition, and thus is replicated
correctly. Statement-based replication of CREATE TABLE ... SELECT is not supported with
sql_generate_invisible_primary_key = ON.
When creating or importing backups of installations where GIPKs are in use, it is possible to exclude
generated invisible primary key columns and values. The --skip-generated-invisible-
primary-key option for mysqldump causes GIPK information to be excluded in the program's output.
15.1.20.12 Setting NDB Comment Options
• NDB_COLUMN Options
• NDB_TABLE Options
   It is possible to set a number of options specific to NDB Cluster in the table comment or column
comments of an NDB table. Table-level options for controlling read from any replica and partition
balance can be embedded in a table comment using NDB_TABLE.
NDB_COLUMN can be used in a column comment to set the size of the blob parts table column used for
storing parts of blob values by NDB to its maximum. This works for BLOB, MEDIUMBLOB, LONGBLOB,
TEXT, MEDIUMTEXT, LONGTEXT, and JSON columns. A column comment can also be used to control
the inline size of a blob column. NDB_COLUMN comments do not support TINYBLOB or TINYTEXT
columns, since these have an inline part (only) of fixed size, and no separate parts to store elsewhere.
NDB_TABLE can be used in a table comment to set options relating to partition balance and whether
the table is fully replicated, among others.
The remainder of this section describes these options and their use.
NDB_COLUMN Options
    In NDB Cluster, a column comment in a CREATE TABLE or ALTER TABLE statement can
also be used to specify an NDB_COLUMN option. NDB supports two column comment options
BLOB_INLINE_SIZE and MAX_BLOB_PART_SIZE. Syntax for these options is shown here:
COMMENT 'NDB_COLUMN=speclist'
speclist := spec[,spec]
spec := 
    BLOB_INLINE_SIZE=value
  | MAX_BLOB_PART_SIZE[={0|1}]
BLOB_INLINE_SIZE specifies the number of bytes to be stored inline by the column; its expected
value is an integer in the range 1 - 29980, inclusive. Setting a value greater than 29980 raises an error;
setting a value less than 1 is allowed, but causes the default inline size for the column type to be used.
You should be aware that the maximum value for this option is actually the maximum number of bytes
that can be stored in one row of an NDB table; every column in the row contributes to this total.
You should also keep in mind, especially when working with TEXT columns, that the value set by
MAX_BLOB_PART_SIZE or BLOB_INLINE_SIZE represents column size in bytes. It does not indicate
the number of characters, which varies according to the character set and collation used by the
column.
To see the effects of this option, first create a table with two BLOB columns, one (b1) with no extra
options, and another (b2) with a setting for BLOB_INLINE_SIZE, as shown here:
mysql> CREATE TABLE t1 (
    ->    a INT NOT NULL PRIMARY KEY,
    ->    b1 BLOB,
    ->    b2 BLOB COMMENT 'NDB_COLUMN=BLOB_INLINE_SIZE=8000'
    ->  ) ENGINE NDB;
Query OK, 0 rows affected (0.32 sec)
You can see the BLOB_INLINE_SIZE settings for the BLOB columns by querying the
ndbinfo.blobs table, like this:
mysql> SELECT 
    ->   column_name AS 'Column Name', 
    ->   inline_size AS 'Inline Size', 
    ->   part_size AS 'Blob Part Size' 
    -> FROM ndbinfo.blobs 
    -> WHERE table_name = 't1';
+-------------+-------------+----------------+
| Column Name | Inline Size | Blob Part Size |
+-------------+-------------+----------------+
| b1          |         256 |           2000 |
| b2          |        8000 |           2000 |
+-------------+-------------+----------------+
2 rows in set (0.01 sec)
You can also check the output from the ndb_desc utility, as shown here, with the relevant lines
displayed using emphasized text:
$> ndb_desc -d test t1
-- t --
Version: 1
Fragment type: HashMapPartition
K Value: 6
Min load factor: 78
Max load factor: 80
Temporary table: no
Number of attributes: 3
Number of primary keys: 1
Length of frm data: 945
Max Rows: 0
Row Checksum: 1
Row GCI: 1
SingleUserMode: 0
ForceVarPart: 1
PartitionCount: 2
FragmentCount: 2
PartitionBalance: FOR_RP_BY_LDM
ExtraRowGciBits: 0
ExtraRowAuthorBits: 0
TableStatus: Retrieved
Table options: readbackup
HashMap: DEFAULT-HASHMAP-3840-2
-- Attributes --
a Int PRIMARY KEY DISTRIBUTION KEY AT=FIXED ST=MEMORY
b1 Blob(256,2000,0) NULL AT=MEDIUM_VAR ST=MEMORY BV=2 BT=NDB$BLOB_64_1
b2 Blob(8000,2000,0) NULL AT=MEDIUM_VAR ST=MEMORY BV=2 BT=NDB$BLOB_64_2
-- Indexes -- 
PRIMARY KEY(a) - UniqueHashIndex
PRIMARY(a) - OrderedIndex
For MAX_BLOB_PART_SIZE, the = sign and the value following it are optional. Using any value other
than 0 or 1 results in a syntax error.
The effect of using MAX_BLOB_PART_SIZE in a column comment is to set the blob part size of a
TEXT or BLOB column to the maximum number of bytes supported for this by NDB (13948). This
option can be applied to any blob column type supported by MySQL except TINYBLOB or TINYTEXT
(BLOB, MEDIUMBLOB, LONGBLOB, TEXT, MEDIUMTEXT, LONGTEXT). Unlike BLOB_INLINE_SIZE,
MAX_BLOB_PART_SIZE has no effect on JSON columns.
To see the effects of this option, we first run the following SQL statement in the mysql client
to create a table with two BLOB columns, one (c1) with no extra options, and another (c2) with
MAX_BLOB_PART_SIZE:
mysql> CREATE TABLE test.t2 (
    ->   p INT PRIMARY KEY, 
    ->   c1 BLOB, 
    ->   c2 BLOB COMMENT 'NDB_COLUMN=MAX_BLOB_PART_SIZE'
    -> ) ENGINE NDB;
Query OK, 0 rows affected (0.32 sec)
From the system shell, run the ndb_desc utility to obtain information about the table just created, as
shown in this example:
$> ndb_desc -d test t2
-- t --
Version: 1
Fragment type: HashMapPartition
K Value: 6
Min load factor: 78
Max load factor: 80
Temporary table: no
Number of attributes: 3
Number of primary keys: 1
Length of frm data: 324
Row Checksum: 1
Row GCI: 1
SingleUserMode: 0
ForceVarPart: 1
FragmentCount: 2
ExtraRowGciBits: 0
ExtraRowAuthorBits: 0
TableStatus: Retrieved
HashMap: DEFAULT-HASHMAP-3840-2
-- Attributes --
p Int PRIMARY KEY DISTRIBUTION KEY AT=FIXED ST=MEMORY
c1 Blob(256,2000,0) NULL AT=MEDIUM_VAR ST=MEMORY BV=2 BT=NDB$BLOB_22_1
c2 Blob(256,13948,0) NULL AT=MEDIUM_VAR ST=MEMORY BV=2 BT=NDB$BLOB_22_2
-- Indexes -- 
PRIMARY KEY(p) - UniqueHashIndex
PRIMARY(p) - OrderedIndex
Column information in the output is listed under Attributes; for columns c1 and c2 it is displayed
here in emphasized text. For c1, the blob part size is 2000, the default value; for c2, it is 13948, as set
by MAX_BLOB_PART_SIZE.
You can also query the ndbinfo.blobs table to see this, as shown here:
mysql> SELECT 
    ->   column_name AS 'Column Name', 
    ->   inline_size AS 'Inline Size', 
    ->   part_size AS 'Blob Part Size' 
    -> FROM ndbinfo.blobs 
    -> WHERE table_name = 't2';
+-------------+-------------+----------------+
| Column Name | Inline Size | Blob Part Size |
+-------------+-------------+----------------+
| c1          |         256 |           2000 |
| c2          |         256 |          13948 |
+-------------+-------------+----------------+
2 rows in set (0.00 sec)
You can change the blob part size for a given blob column of an NDB table using an ALTER TABLE
statement such as this one, and verifying the changes afterwards using SHOW CREATE TABLE:
mysql> ALTER TABLE test.t2 
    ->    DROP COLUMN c1, 
    ->     ADD COLUMN c1 BLOB COMMENT 'NDB_COLUMN=MAX_BLOB_PART_SIZE',
    ->     CHANGE COLUMN c2 c2 BLOB AFTER c1;
Query OK, 0 rows affected (0.47 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql> SHOW CREATE TABLE test.t2\G
*************************** 1. row ***************************
       Table: t
Create Table: CREATE TABLE `t2` (
  `p` int(11) NOT NULL,
  `c1` blob COMMENT 'NDB_COLUMN=MAX_BLOB_PART_SIZE',
  `c2` blob,
  PRIMARY KEY (`p`)
) ENGINE=ndbcluster DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
1 row in set (0.00 sec)
mysql> EXIT
Bye
The output of ndb_desc shows that the blob part sizes of the columns have been changed as
expected:
$> ndb_desc -d test t2
-- t --
Version: 16777220
Fragment type: HashMapPartition
K Value: 6
Min load factor: 78
Max load factor: 80
Temporary table: no
Number of attributes: 3
Number of primary keys: 1
Length of frm data: 324
Row Checksum: 1
Row GCI: 1
SingleUserMode: 0
ForceVarPart: 1
FragmentCount: 2
ExtraRowGciBits: 0
ExtraRowAuthorBits: 0
TableStatus: Retrieved
HashMap: DEFAULT-HASHMAP-3840-2
-- Attributes --
p Int PRIMARY KEY DISTRIBUTION KEY AT=FIXED ST=MEMORY
c1 Blob(256,13948,0) NULL AT=MEDIUM_VAR ST=MEMORY BV=2 BT=NDB$BLOB_26_1
c2 Blob(256,2000,0) NULL AT=MEDIUM_VAR ST=MEMORY BV=2 BT=NDB$BLOB_26_2
-- Indexes -- 
PRIMARY KEY(p) - UniqueHashIndex
PRIMARY(p) - OrderedIndex
You can also see the change by running the query against ndbinfo.blobs again:
mysql> SELECT 
    ->   column_name AS 'Column Name', 
    ->   inline_size AS 'Inline Size', 
    ->   part_size AS 'Blob Part Size' 
    -> FROM ndbinfo.blobs 
    -> WHERE table_name = 't2';
+-------------+-------------+----------------+
| Column Name | Inline Size | Blob Part Size |
+-------------+-------------+----------------+
| c1          |         256 |          13948 |
| c2          |         256 |           2000 |
+-------------+-------------+----------------+
2 rows in set (0.00 sec)
It is possible to set both BLOB_INLINE_SIZE and MAX_BLOB_PART_SIZE for a blob column, as
shown in this CREATE TABLE statement:
mysql> CREATE TABLE test.t3 (
    ->   p INT NOT NULL PRIMARY KEY,
    ->   c1 JSON,
    ->   c2 JSON COMMENT 'NDB_COLUMN=BLOB_INLINE_SIZE=5000,MAX_BLOB_PART_SIZE'
    -> ) ENGINE NDB;
Query OK, 0 rows affected (0.28 sec)
Querying the blobs table shows us that the statement worked as expected:
mysql> SELECT 
    ->   column_name AS 'Column Name', 
    ->   inline_size AS 'Inline Size', 
    ->   part_size AS 'Blob Part Size' 
    -> FROM ndbinfo.blobs 
    -> WHERE table_name = 't3';
+-------------+-------------+----------------+
| Column Name | Inline Size | Blob Part Size |
+-------------+-------------+----------------+
| c1          |        4000 |           8100 |
| c2          |        5000 |           8100 |
+-------------+-------------+----------------+
2 rows in set (0.00 sec)
You can also verify that the statement worked by checking the output of ndb_desc.
Changing a column's blob part size must be done using a copying ALTER TABLE; this operation
cannot be performed online (see Section 25.6.12, “Online Operations with ALTER TABLE in NDB
Cluster”).
For more information about how NDB stores columns of blob types, see String Type Storage
Requirements.
NDB_TABLE Options
     For an NDB Cluster table, the table comment in a CREATE TABLE or ALTER TABLE statement
can also be used to specify an NDB_TABLE option, which consists of one or more name-value pairs,
separated by commas if need be, following the string NDB_TABLE=. Complete syntax for names and
values syntax is shown here:
COMMENT="NDB_TABLE=ndb_table_option[,ndb_table_option[,...]]"
ndb_table_option: {
    NOLOGGING={1 | 0}
  | READ_BACKUP={1 | 0}
  | PARTITION_BALANCE={FOR_RP_BY_NODE | FOR_RA_BY_NODE | FOR_RP_BY_LDM
                      | FOR_RA_BY_LDM | FOR_RA_BY_LDM_X_2
                      | FOR_RA_BY_LDM_X_3 | FOR_RA_BY_LDM_X_4}
  | FULLY_REPLICATED={1 | 0}
}
Spaces are not permitted within the quoted string. The string is case-insensitive.
The four NDB table options that can be set as part of a comment in this way are described in more
detail in the next few paragraphs.
   NOLOGGING: By default, NDB tables are logged, and checkpointed. This makes them durable to
whole cluster failures. Using NOLOGGING when creating or altering a table means that this table is not
redo logged or included in local checkpoints. In this case, the table is still replicated across the data
nodes for high availability, and updated using transactions, but changes made to it are not recorded in
the data node's redo logs, and its content is not checkpointed to disk; when recovering from a cluster
failure, the cluster retains the table definition, but none of its rows—that is, the table is empty.
Using such nonlogging tables reduces the data node's demands on disk I/O and storage, as well as
CPU for checkpointing CPU. This may be suitable for short-lived data which is frequently updated, and
where the loss of all data in the unlikely event of a total cluster failure is acceptable.
It is also possible to use the ndb_table_no_logging system variable to cause any NDB tables
created or altered while this variable is in effect to behave as though it had been created with the
NOLOGGING comment. Unlike when using the comment directly, there is nothing in this case in the
output of SHOW CREATE TABLE to indicate that it is a nonlogging table. Using the table comment
approach is recommended since it offers per-table control of the feature, and this aspect of the table
schema is embedded in the table creation statement where it can be found easily by SQL-based tools.
   READ_BACKUP: Setting this option to 1 has the same effect as though ndb_read_backup were
enabled; enables reading from any replica. Doing so greatly improves the performance of reads from
the table at a relatively small cost to write performance. 1 is the default for READ_BACKUP, and the
default for ndb_read_backup is ON (previously, read from any replica was disabled by default).
You can set READ_BACKUP for an existing table online, using an ALTER TABLE statement similar to
one of those shown here:
ALTER TABLE ... ALGORITHM=INPLACE, COMMENT="NDB_TABLE=READ_BACKUP=1";
ALTER TABLE ... ALGORITHM=INPLACE, COMMENT="NDB_TABLE=READ_BACKUP=0";
For more information about the ALGORITHM option for ALTER TABLE, see Section 25.6.12, “Online
Operations with ALTER TABLE in NDB Cluster”.
   PARTITION_BALANCE: Provides additional control over assignment and placement of partitions. The
following four schemes are supported:
1. FOR_RP_BY_NODE: One partition per node.
Only one LDM on each node stores a primary partition. Each partition is stored in the same LDM
(same ID) on all nodes.
2. FOR_RA_BY_NODE: One partition per node group.
Each node stores a single partition, which can be either a primary replica or a backup replica. Each
partition is stored in the same LDM on all nodes.
3. FOR_RP_BY_LDM: One partition for each LDM on each node; the default.
This is the setting used if READ_BACKUP is set to 1.
4. FOR_RA_BY_LDM: One partition per LDM in each node group.
These partitions can be primary or backup partitions.
5. FOR_RA_BY_LDM_X_2: Two partitions per LDM in each node group.
These partitions can be primary or backup partitions.
6. FOR_RA_BY_LDM_X_3: Three partitions per LDM in each node group.
These partitions can be primary or backup partitions.
7. FOR_RA_BY_LDM_X_4: Four partitions per LDM in each node group.
These partitions can be primary or backup partitions.
PARTITION_BALANCE is the preferred interface for setting the number of partitions per table. Using
MAX_ROWS to force the number of partitions is deprecated but continues to be supported for backward
compatibility; it is subject to removal in a future release of MySQL NDB Cluster. (Bug #81759, Bug
#23544301)
  FULLY_REPLICATED controls whether the table is fully replicated, that is, whether each data node
has a complete copy of the table. To enable full replication of the table, use FULLY_REPLICATED=1.
This setting can also be controlled using the ndb_fully_replicated system variable.
Setting it to ON enables the option by default for all new NDB tables; the default is OFF. The
ndb_data_node_neighbour system variable is also used for fully replicated tables, to ensure that
when a fully replicated table is accessed, we access the data node which is local to this MySQL Server.
An example of a CREATE TABLE statement using such a comment when creating an NDB table is
shown here:
mysql> CREATE TABLE t1 (
     >     c1 INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
     >     c2 VARCHAR(100),
     >     c3 VARCHAR(100) )
     > ENGINE=NDB
     >
COMMENT="NDB_TABLE=READ_BACKUP=0,PARTITION_BALANCE=FOR_RP_BY_NODE";
The comment is displayed as part of the output of SHOW CREATE TABLE. The text of the comment is
also available from querying the MySQL Information Schema TABLES table, as in this example:
mysql> SELECT TABLE_NAME, TABLE_SCHEMA, TABLE_COMMENT
     > FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME="t1"\G
*************************** 1. row ***************************
   TABLE_NAME: t1
 TABLE_SCHEMA: test
TABLE_COMMENT: NDB_TABLE=READ_BACKUP=0,PARTITION_BALANCE=FOR_RP_BY_NODE
1 row in set (0.01 sec)
This comment syntax is also supported with ALTER TABLE statements for NDB tables, as shown here:
mysql> ALTER TABLE t1 COMMENT="NDB_TABLE=PARTITION_BALANCE=FOR_RA_BY_NODE";
Query OK, 0 rows affected (0.40 sec)
Records: 0  Duplicates: 0  Warnings: 0
The TABLE_COMMENT column displays the comment that is required to re-create the table as it is
following the ALTER TABLE statement, like this:
mysql> SELECT TABLE_NAME, TABLE_SCHEMA, TABLE_COMMENT
    ->     FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME="t1"\G
*************************** 1. row ***************************
   TABLE_NAME: t1
 TABLE_SCHEMA: test
TABLE_COMMENT: NDB_TABLE=READ_BACKUP=0,PARTITION_BALANCE=FOR_RP_BY_NODE
1 row in set (0.01 sec)
mysql> SELECT TABLE_NAME, TABLE_SCHEMA, TABLE_COMMENT
     > FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME="t1";
+------------+--------------+--------------------------------------------------+
| TABLE_NAME | TABLE_SCHEMA | TABLE_COMMENT                                    |
+------------+--------------+--------------------------------------------------+
| t1         | c            | NDB_TABLE=PARTITION_BALANCE=FOR_RA_BY_NODE       |
| t1         | d            |                                                  |
+------------+--------------+--------------------------------------------------+
2 rows in set (0.01 sec)
Keep in mind that a table comment used with ALTER TABLE replaces any existing comment which the
table might have.
mysql> ALTER TABLE t1 COMMENT="NDB_TABLE=PARTITION_BALANCE=FOR_RA_BY_NODE";
Query OK, 0 rows affected (0.40 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql> SELECT TABLE_NAME, TABLE_SCHEMA, TABLE_COMMENT
     > FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME="t1";
+------------+--------------+--------------------------------------------------+
| TABLE_NAME | TABLE_SCHEMA | TABLE_COMMENT                                    |
+------------+--------------+--------------------------------------------------+
| t1         | c            | NDB_TABLE=PARTITION_BALANCE=FOR_RA_BY_NODE       |
| t1         | d            |                                                  |
+------------+--------------+--------------------------------------------------+
2 rows in set (0.01 sec)
You can also see the value of the PARTITION_BALANCE option in the output of ndb_desc. ndb_desc
also shows whether the READ_BACKUP and FULLY_REPLICATED options are set for the table. See the
description of this program for more information.