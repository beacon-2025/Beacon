15.7.8 Other Administrative Statements
15.7.8.1 BINLOG Statement
BINLOG 'str'
BINLOG is an internal-use statement. It is generated by the mysqlbinlog program as the printable
representation of certain events in binary log files. (See Section 6.6.9, “mysqlbinlog — Utility for
Processing Binary Log Files”.) The 'str' value is a base 64-encoded string the that server decodes to
determine the data change indicated by the corresponding event.
To execute BINLOG statements when applying mysqlbinlog output, a user account requires the
BINLOG_ADMIN privilege (or the deprecated SUPER privilege), or the REPLICATION_APPLIER
privilege plus the appropriate privileges to execute each log event.
This statement can execute only format description events and row events.
15.7.8.2 CACHE INDEX Statement
CACHE INDEX {
      tbl_index_list [, tbl_index_list] ...
    | tbl_name PARTITION (partition_list)
  }
  IN key_cache_name
tbl_index_list:
  tbl_name [{INDEX|KEY} (index_name[, index_name] ...)]
partition_list: {
    partition_name[, partition_name] ...
  | ALL
}
The CACHE INDEX statement assigns table indexes to a specific key cache. It applies only to MyISAM
tables, including partitioned MyISAM tables. After the indexes have been assigned, they can be
preloaded into the cache if desired with LOAD INDEX INTO CACHE.
The following statement assigns indexes from the tables t1, t2, and t3 to the key cache named
hot_cache:
mysql> CACHE INDEX t1, t2, t3 IN hot_cache;
+---------+--------------------+----------+----------+
| Table   | Op                 | Msg_type | Msg_text |
+---------+--------------------+----------+----------+
| test.t1 | assign_to_keycache | status   | OK       |
| test.t2 | assign_to_keycache | status   | OK       |
| test.t3 | assign_to_keycache | status   | OK       |
+---------+--------------------+----------+----------+
The syntax of CACHE INDEX enables you to specify that only particular indexes from a table should be
assigned to the cache. However, the implementation assigns all the table's indexes to the cache, so
there is no reason to specify anything other than the table name.
The key cache referred to in a CACHE INDEX statement can be created by setting its size with a
parameter setting statement or in the server parameter settings. For example:
SET GLOBAL keycache1.key_buffer_size=128*1024;
Key cache parameters are accessed as members of a structured system variable. See Section 7.1.9.5,
“Structured System Variables”.
A key cache must exist before you assign indexes to it, or an error occurs:
mysql> CACHE INDEX t1 IN non_existent_cache;
ERROR 1284 (HY000): Unknown key cache 'non_existent_cache'
By default, table indexes are assigned to the main (default) key cache created at the server startup.
When a key cache is destroyed, all indexes assigned to it are reassigned to the default key cache.
Index assignment affects the server globally: If one client assigns an index to a given cache, this cache
is used for all queries involving the index, no matter which client issues the queries.
CACHE INDEX is supported for partitioned MyISAM tables. You can assign one or more indexes for
one, several, or all partitions to a given key cache. For example, you can do the following:
CREATE TABLE pt (c1 INT, c2 VARCHAR(50), INDEX i(c1))
    ENGINE=MyISAM
    PARTITION BY HASH(c1)
    PARTITIONS 4;
SET GLOBAL kc_fast.key_buffer_size = 128 * 1024;
SET GLOBAL kc_slow.key_buffer_size = 128 * 1024;
CACHE INDEX pt PARTITION (p0) IN kc_fast;
CACHE INDEX pt PARTITION (p1, p3) IN kc_slow;
The previous set of statements performs the following actions:
• Creates a partitioned table with 4 partitions; these partitions are automatically named p0, ..., p3; this
table has an index named i on column c1.
• Creates 2 key caches named kc_fast and kc_slow
• Assigns the index for partition p0 to the kc_fast key cache and the index for partitions p1 and p3
to the kc_slow key cache; the index for the remaining partition (p2) uses the server's default key
cache.
If you wish instead to assign the indexes for all partitions in table pt to a single key cache named
kc_all, you can use either of the following two statements:
CACHE INDEX pt PARTITION (ALL) IN kc_all;
CACHE INDEX pt IN kc_all;
The two statements just shown are equivalent, and issuing either one has exactly the same effect. In
other words, if you wish to assign indexes for all partitions of a partitioned table to the same key cache,
the PARTITION (ALL) clause is optional.
When assigning indexes for multiple partitions to a key cache, the partitions need not be contiguous,
and you need not list their names in any particular order. Indexes for any partitions not explicitly
assigned to a key cache automatically use the server default key cache.
Index preloading is also supported for partitioned MyISAM tables. For more information, see
Section 15.7.8.5, “LOAD INDEX INTO CACHE Statement”.
15.7.8.3 FLUSH Statement
FLUSH [NO_WRITE_TO_BINLOG | LOCAL] {
    flush_option [, flush_option] ...
  | tables_option
}
flush_option: {
    BINARY LOGS
  | ENGINE LOGS
  | ERROR LOGS
  | GENERAL LOGS
  | LOGS
  | PRIVILEGES
  | OPTIMIZER_COSTS
  | RELAY LOGS [FOR CHANNEL channel]
  | SLOW LOGS
  | STATUS
  | USER_RESOURCES
}
tables_option: {
    table_synonym
  | table_synonym tbl_name [, tbl_name] ...
  | table_synonym WITH READ LOCK
  | table_synonym tbl_name [, tbl_name] ... WITH READ LOCK
  | table_synonym tbl_name [, tbl_name] ... FOR EXPORT
}
table_synonym: {
    TABLE
  | TABLES
}
The FLUSH statement has several variant forms that clear or reload various internal caches, flush
tables, or acquire locks. Each FLUSH operation requires the privileges indicated in its description.
Note
It is not possible to issue FLUSH statements within stored functions or triggers.
However, you may use FLUSH in stored procedures, so long as these are not
called from stored functions or triggers. See Section 27.9, “Restrictions on
Stored Programs”.
By default, the server writes FLUSH statements to the binary log so that they replicate to replicas. To
suppress logging, specify the optional NO_WRITE_TO_BINLOG keyword or its alias LOCAL.
Note
FLUSH LOGS, FLUSH BINARY LOGS, FLUSH TABLES WITH READ LOCK
(with or without a table list), and FLUSH TABLES tbl_name ... FOR
EXPORT are not written to the binary log in any case because they would cause
problems if replicated to a replica.
The FLUSH statement causes an implicit commit. See Section 15.3.3, “Statements That Cause an
Implicit Commit”.
The mysqladmin utility provides a command-line interface to some flush operations, using
commands such as flush-logs, flush-privileges, flush-status, and flush-tables. See
Section 6.5.2, “mysqladmin — A MySQL Server Administration Program”.
Sending a SIGHUP or SIGUSR1 signal to the server causes several flush operations to occur that are
similar to various forms of the FLUSH statement. Signals can be sent by the root system account or
the system account that owns the server process. This enables the flush operations to be performed
without having to connect to the server, which requires a MySQL account that has privileges sufficient
for those operations. See Section 6.10, “Unix Signal Handling in MySQL”.
The RESET statement is similar to FLUSH. See Section 15.7.8.6, “RESET Statement”, for information
about using RESET with replication.
The following list describes the permitted FLUSH statement flush_option values. For descriptions of
the permitted tables_option values, see FLUSH TABLES Syntax.
• FLUSH BINARY LOGS
Closes and reopens any binary log file to which the server is writing. If binary logging is enabled, the
sequence number of the binary log file is incremented by one relative to the previous file.
This operation requires the RELOAD privilege.
• FLUSH ENGINE LOGS
Closes and reopens any flushable logs for installed storage engines. This causes InnoDB to flush its
logs to disk.
This operation requires the RELOAD privilege.
• FLUSH ERROR LOGS
Closes and reopens any error log file to which the server is writing.
This operation requires the RELOAD privilege.
• FLUSH GENERAL LOGS
Closes and reopens any general query log file to which the server is writing.
This operation requires the RELOAD privilege.
This operation has no effect on tables used for the general query log (see Section 7.4.1, “Selecting
General Query Log and Slow Query Log Output Destinations”).
• FLUSH LOGS
Closes and reopens any log file to which the server is writing.
This operation requires the RELOAD privilege.
The effect of this operation is equivalent to the combined effects of these operations:
FLUSH BINARY LOGS
FLUSH ENGINE LOGS
FLUSH ERROR LOGS
FLUSH GENERAL LOGS
FLUSH RELAY LOGS
FLUSH SLOW LOGS
• FLUSH OPTIMIZER_COSTS
Re-reads the cost model tables so that the optimizer starts using the current cost estimates stored in
them.
This operation requires the FLUSH_OPTIMIZER_COSTS or RELOAD privilege.
The server writes a warning to the error log for any unrecognized cost model table entries. For
information about these tables, see Section 10.9.5, “The Optimizer Cost Model”. This operation
affects only sessions that begin subsequent to the flush. Existing sessions continue to use the cost
estimates that were current when they began.
• FLUSH PRIVILEGES
Re-reads the privileges from the grant tables in the mysql system schema. As part of this operation,
the server reads the global_grants table containing dynamic privilege assignments and registers
any unregistered privileges found there.
Reloading the grant tables is necessary to enable updates to MySQL privileges and users only if you
make such changes directly to the grant tables; it is not needed for account management statements
such as GRANT or REVOKE, which take effect immediately. See Section 8.2.13, “When Privilege
Changes Take Effect”, for more information.
This operation requires the RELOAD or FLUSH_PRIVILEGES privilege.
If the --skip-grant-tables option was specified at server startup to disable the MySQL privilege
system, FLUSH PRIVILEGES provides a way to enable the privilege system at runtime.
Resets failed-login tracking (or enables it if the server was started with --skip-grant-tables)
and unlocks any temporarily locked accounts. See Section 8.2.15, “Password Management”.
Frees memory cached by the server as a result of GRANT, CREATE USER, CREATE SERVER, and
INSTALL PLUGIN statements. This memory is not released by the corresponding REVOKE, DROP
USER, DROP SERVER, and UNINSTALL PLUGIN statements, so for a server that executes many
instances of the statements that cause caching, there is an increase in cached memory use unless it
is freed with FLUSH PRIVILEGES.
Clears the in-memory cache used by the caching_sha2_password authentication plugin. See
Cache Operation for SHA-2 Pluggable Authentication.
• FLUSH RELAY LOGS [FOR CHANNEL channel]
Closes and reopens any relay log file to which the server is writing. If relay logging is enabled, the
sequence number of the relay log file is incremented by one relative to the previous file.
This operation requires the RELOAD privilege.
The FOR CHANNEL channel clause enables you to name which replication channel the operation
applies to. Execute FLUSH RELAY LOGS FOR CHANNEL channel to flush the relay log for a
specific replication channel. If no channel is named and no extra replication channels exist, the
operation applies to the default channel. If no channel is named and multiple replication channels
exist, the operation applies to all replication channels. For more information, see Section 19.2.2,
“Replication Channels”.
• FLUSH SLOW LOGS
Closes and reopens any slow query log file to which the server is writing.
This operation requires the RELOAD privilege.
This operation has no effect on tables used for the slow query log (see Section 7.4.1, “Selecting
General Query Log and Slow Query Log Output Destinations”).
• FLUSH STATUS
Flushes status indicators.
This operation adds the current thread's session status variable values to the global values and
resets the session values to zero. Some global variables may be reset to zero as well. It also resets
the counters for key caches (default and named) to zero and sets Max_used_connections to the
current number of open connections. This information may be of use when debugging a query. See
Section 1.6, “How to Report Bugs or Problems”.
FLUSH STATUS is unaffected by read_only or super_read_only, and is always written to the
binary log.
This operation requires the FLUSH_STATUS or RELOAD privilege.
• FLUSH USER_RESOURCES
Resets all per-hour user resource indicators to zero.
This operation requires the FLUSH_USER_RESOURCES or RELOAD privilege.
Resetting resource indicators enables clients that have reached their hourly connection, query, or
update limits to resume activity immediately. FLUSH USER_RESOURCES does not apply to the limit
on maximum simultaneous connections that is controlled by the max_user_connections system
variable. See Section 8.2.21, “Setting Account Resource Limits”.
FLUSH TABLES Syntax
FLUSH TABLES flushes tables, and, depending on the variant used, acquires locks. Any TABLES
variant used in a FLUSH statement must be the only option used. FLUSH TABLE is a synonym for
FLUSH TABLES.
Note
The descriptions here that indicate tables are flushed by closing them apply
differently for InnoDB, which flushes table contents to disk but leaves them
open. This still permits table files to be copied while the tables are open, as long
as other activity does not modify them.
• FLUSH TABLES
Closes all open tables, forces all tables in use to be closed, and flushes the prepared statement
cache.
This operation requires the FLUSH_TABLES or RELOAD privilege.
For information about prepared statement caching, see Section 10.10.3, “Caching of Prepared
Statements and Stored Programs”.
FLUSH TABLES is not permitted when there is an active LOCK TABLES ... READ. To flush and
lock tables, use FLUSH TABLES tbl_name ... WITH READ LOCK instead.
• FLUSH TABLES tbl_name [, tbl_name] ...
With a list of one or more comma-separated table names, this operation is like FLUSH TABLES with
no names except that the server flushes only the named tables. If a named table does not exist, no
error occurs.
This operation requires the FLUSH_TABLES or RELOAD privilege.
• FLUSH TABLES WITH READ LOCK
Closes all open tables and locks all tables for all databases with a global read lock.
This operation requires the FLUSH_TABLES or RELOAD privilege.
This operation is a very convenient way to get backups if you have a file system such as Veritas or
ZFS that can take snapshots in time. Use UNLOCK TABLES to release the lock.
FLUSH TABLES WITH READ LOCK acquires a global read lock rather than table locks, so it is not
subject to the same behavior as LOCK TABLES and UNLOCK TABLES with respect to table locking
and implicit commits:
• UNLOCK TABLES implicitly commits any active transaction only if any tables currently have been
locked with LOCK TABLES. The commit does not occur for UNLOCK TABLES following FLUSH
TABLES WITH READ LOCK because the latter statement does not acquire table locks.
• Beginning a transaction causes table locks acquired with LOCK TABLES to be released, as though
you had executed UNLOCK TABLES. Beginning a transaction does not release a global read lock
acquired with FLUSH TABLES WITH READ LOCK.
FLUSH TABLES WITH READ LOCK does not prevent the server from inserting rows into the log
tables (see Section 7.4.1, “Selecting General Query Log and Slow Query Log Output Destinations”).
• FLUSH TABLES tbl_name [, tbl_name] ... WITH READ LOCK
Flushes and acquires read locks for the named tables.
This operation requires the FLUSH_TABLES or RELOAD privilege. Because it acquires table locks, it
also requires the LOCK TABLES privilege for each table.
The operation first acquires exclusive metadata locks for the tables, so it waits for transactions that
have those tables open to complete. Then the operation flushes the tables from the table cache,
reopens the tables, acquires table locks (like LOCK TABLES ... READ), and downgrades the
metadata locks from exclusive to shared. After the operation acquires locks and downgrades the
metadata locks, other sessions can read but not modify the tables.
This operation applies only to existing base (non-TEMPORARY) tables. If a name refers to a base
table, that table is used. If it refers to a TEMPORARY table, it is ignored. If a name applies to a view,
an ER_WRONG_OBJECT error occurs. Otherwise, an ER_NO_SUCH_TABLE error occurs.
Use UNLOCK TABLES to release the locks, LOCK TABLES to release the locks and acquire other
locks, or START TRANSACTION to release the locks and begin a new transaction.
This FLUSH TABLES variant enables tables to be flushed and locked in a single operation. It
provides a workaround for the restriction that FLUSH TABLES is not permitted when there is an
active LOCK TABLES ... READ.
This operation does not perform an implicit UNLOCK TABLES, so an error results if you perform the
operation while there is any active LOCK TABLES or use it a second time without first releasing the
locks acquired.
If a flushed table was opened with HANDLER, the handler is implicitly flushed and loses its position.
• FLUSH TABLES tbl_name [, tbl_name] ... FOR EXPORT
This FLUSH TABLES variant applies to InnoDB tables. It ensures that changes to the named tables
have been flushed to disk so that binary table copies can be made while the server is running.
This operation requires the FLUSH_TABLES or RELOAD privilege. Because it acquires locks on tables
in preparation for exporting them, it also requires the LOCK TABLES and SELECT privileges for each
table.
The operation works like this:
1. It acquires shared metadata locks for the named tables. The operation blocks as long as other
sessions have active transactions that have modified those tables or hold table locks for them.
When the locks have been acquired, the operation blocks transactions that attempt to update the
tables, while permitting read-only operations to continue.
2. It checks whether all storage engines for the tables support FOR EXPORT. If any do not, an
ER_ILLEGAL_HA error occurs and the operation fails.
3. The operation notifies the storage engine for each table to make the table ready for export. The
storage engine must ensure that any pending changes are written to disk.
4. The operation puts the session in lock-tables mode so that the metadata locks acquired earlier
are not released when the FOR EXPORT operation completes.
This operation applies only to existing base (non-TEMPORARY) tables. If a name refers to a base
table, that table is used. If it refers to a TEMPORARY table, it is ignored. If a name applies to a view,
an ER_WRONG_OBJECT error occurs. Otherwise, an ER_NO_SUCH_TABLE error occurs.
InnoDB supports FOR EXPORT for tables that have their own .ibd file file (that is, tables created
with the innodb_file_per_table setting enabled). InnoDB ensures when notified by the FOR
EXPORT operation that any changes have been flushed to disk. This permits a binary copy of
table contents to be made while the FOR EXPORT operation is in effect because the .ibd file is
transaction consistent and can be copied while the server is running. FOR EXPORT does not apply to
InnoDB system tablespace files, or to InnoDB tables that have FULLTEXT indexes.
FLUSH TABLES ...FOR EXPORT is supported for partitioned InnoDB tables.
When notified by FOR EXPORT, InnoDB writes to disk certain kinds of data that is normally held
in memory or in separate disk buffers outside the tablespace files. For each table, InnoDB also
produces a file named table_name.cfg in the same database directory as the table. The .cfg file
contains metadata needed to reimport the tablespace files later, into the same or different server.
When the FOR EXPORT operation completes, InnoDB has flushed all dirty pages to the table data
files. Any change buffer entries are merged prior to flushing. At this point, the tables are locked and
quiescent: The tables are in a transactionally consistent state on disk and you can copy the .ibd
tablespace files along with the corresponding .cfg files to get a consistent snapshot of those tables.
For the procedure to reimport the copied table data into a MySQL instance, see Section 17.6.1.3,
“Importing InnoDB Tables”.
After you are done with the tables, use UNLOCK TABLES to release the locks, LOCK TABLES to
release the locks and acquire other locks, or START TRANSACTION to release the locks and begin a
new transaction.
While any of these statements is in effect within the session, attempts to use FLUSH TABLES ...
FOR EXPORT produce an error:
FLUSH TABLES ... WITH READ LOCK
FLUSH TABLES ... FOR EXPORT
LOCK TABLES ... READ
LOCK TABLES ... WRITE
While FLUSH TABLES ... FOR EXPORT is in effect within the session, attempts to use any of
these statements produce an error:
FLUSH TABLES WITH READ LOCK
FLUSH TABLES ... WITH READ LOCK
FLUSH TABLES ... FOR EXPORT
15.7.8.4 KILL Statement
KILL [CONNECTION | QUERY] processlist_id
Each connection to mysqld runs in a separate thread. You can kill a thread with the KILL
processlist_id statement.
Thread processlist identifiers can be determined from the ID column of the INFORMATION_SCHEMA
PROCESSLIST table, the Id column of SHOW PROCESSLIST output, and the PROCESSLIST_ID
column of the Performance Schema threads table. The value for the current thread is returned by the
CONNECTION_ID() function.
KILL permits an optional CONNECTION or QUERY modifier:
• KILL CONNECTION is the same as KILL with no modifier: It terminates the connection associated
with the given processlist_id, after terminating any statement the connection is executing.
• KILL QUERY terminates the statement the connection is currently executing, but leaves the
connection itself intact.
The ability to see which threads are available to be killed depends on the PROCESS privilege:
• Without PROCESS, you can see only your own threads.
• With PROCESS, you can see all threads.
The ability to kill threads and statements depends on the CONNECTION_ADMIN privilege and the
deprecated SUPER privilege:
• Without CONNECTION_ADMIN or SUPER, you can kill only your own threads and statements.
• With CONNECTION_ADMIN or SUPER, you can kill all threads and statements, except that to affect
a thread or statement that is executing with the SYSTEM_USER privilege, your own session must
additionally have the SYSTEM_USER privilege.
You can also use the mysqladmin processlist and mysqladmin kill commands to examine
and kill threads.
When you use KILL, a thread-specific kill flag is set for the thread. In most cases, it might take some
time for the thread to die because the kill flag is checked only at specific intervals:
• During SELECT operations, for ORDER BY and GROUP BY loops, the flag is checked after reading a
block of rows. If the kill flag is set, the statement is aborted.
• ALTER TABLE operations that make a table copy check the kill flag periodically for each few copied
rows read from the original table. If the kill flag was set, the statement is aborted and the temporary
table is deleted.
The KILL statement returns without waiting for confirmation, but the kill flag check aborts the
operation within a reasonably small amount of time. Aborting the operation to perform any necessary
cleanup also takes some time.
• During UPDATE or DELETE operations, the kill flag is checked after each block read and after
each updated or deleted row. If the kill flag is set, the statement is aborted. If you are not using
transactions, the changes are not rolled back.
• GET_LOCK() aborts and returns NULL.
• If the thread is in the table lock handler (state: Locked), the table lock is quickly aborted.
• If the thread is waiting for free disk space in a write call, the write is aborted with a “disk full” error
message.
• EXPLAIN ANALYZE aborts and prints the first row of output.
Warning
Killing a REPAIR TABLE or OPTIMIZE TABLE operation on a MyISAM table
results in a table that is corrupted and unusable. Any reads or writes to such a
table fail until you optimize or repair it again (without interruption).
15.7.8.5 LOAD INDEX INTO CACHE Statement
LOAD INDEX INTO CACHE
  tbl_index_list [, tbl_index_list] ...
tbl_index_list:
  tbl_name
    [PARTITION (partition_list)]
    [{INDEX|KEY} (index_name[, index_name] ...)]
    [IGNORE LEAVES]
partition_list: {
    partition_name[, partition_name] ...
  | ALL
}
The LOAD INDEX INTO CACHE statement preloads a table index into the key cache to which it has
been assigned by an explicit CACHE INDEX statement, or into the default key cache otherwise.
LOAD INDEX INTO CACHE applies only to MyISAM tables, including partitioned MyISAM tables. In
addition, indexes on partitioned tables can be preloaded for one, several, or all partitions.
The IGNORE LEAVES modifier causes only blocks for the nonleaf nodes of the index to be preloaded.
IGNORE LEAVES is also supported for partitioned MyISAM tables.
The following statement preloads nodes (index blocks) of indexes for the tables t1 and t2:
mysql> LOAD INDEX INTO CACHE t1, t2 IGNORE LEAVES;
+---------+--------------+----------+----------+
| Table   | Op           | Msg_type | Msg_text |
+---------+--------------+----------+----------+
| test.t1 | preload_keys | status   | OK       |
| test.t2 | preload_keys | status   | OK       |
+---------+--------------+----------+----------+
This statement preloads all index blocks from t1. It preloads only blocks for the nonleaf nodes from t2.
The syntax of LOAD INDEX INTO CACHE enables you to specify that only particular indexes from a
table should be preloaded. However, the implementation preloads all the table's indexes into the cache,
so there is no reason to specify anything other than the table name.
It is possible to preload indexes on specific partitions of partitioned MyISAM tables. For example, of
the following 2 statements, the first preloads indexes for partition p0 of a partitioned table pt, while the
second preloads the indexes for partitions p1 and p3 of the same table:
LOAD INDEX INTO CACHE pt PARTITION (p0);
LOAD INDEX INTO CACHE pt PARTITION (p1, p3);
To preload the indexes for all partitions in table pt, you can use either of the following two statements:
LOAD INDEX INTO CACHE pt PARTITION (ALL);
LOAD INDEX INTO CACHE pt;
The two statements just shown are equivalent, and issuing either one has exactly the same effect.
In other words, if you wish to preload indexes for all partitions of a partitioned table, the PARTITION
(ALL) clause is optional.
When preloading indexes for multiple partitions, the partitions need not be contiguous, and you need
not list their names in any particular order.
LOAD INDEX INTO CACHE ... IGNORE LEAVES fails unless all indexes in a table have the
same block size. To determine index block sizes for a table, use myisamchk -dv and check the
Blocksize column.
15.7.8.6 RESET Statement
RESET reset_option [, reset_option] ...
reset_option: {
    BINARY LOGS AND GTIDS
  | REPLICA
}
The RESET statement is used to clear the state of various server operations. You must have the
RELOAD privilege to execute RESET.
For information about the RESET PERSIST statement that removes persisted global system variables,
see Section 15.7.8.7, “RESET PERSIST Statement”.
RESET acts as a stronger version of the FLUSH statement. See Section 15.7.8.3, “FLUSH Statement”.
The RESET statement causes an implicit commit. See Section 15.3.3, “Statements That Cause an
Implicit Commit”.
The following list describes the permitted RESET statement reset_option values:
• RESET BINARY LOGS AND GTIDS
Deletes all binary logs listed in the index file, resets the binary log index file to be empty, and creates
a new binary log file.
• RESET REPLICA
Makes the replica forget its replication position in the source binary logs. Also resets the relay log by
deleting any existing relay log files and beginning a new one.
15.7.8.7 RESET PERSIST Statement
RESET PERSIST [[IF EXISTS] system_var_name]
RESET PERSIST removes persisted global system variable settings from the mysqld-auto.cnf
option file in the data directory. Removing a persisted system variable causes the variable no longer to
be initialized from mysqld-auto.cnf at server startup. For more information about persisting system
variables and the mysqld-auto.cnf file, see Section 7.1.9.3, “Persisted System Variables”.
The privileges required for RESET PERSIST depend on the type of system variable to be removed:
• For dynamic system variables, this statement requires the SYSTEM_VARIABLES_ADMIN privilege (or
the deprecated SUPER privilege).
• For read-only system variables, this statement requires the SYSTEM_VARIABLES_ADMIN and
PERSIST_RO_VARIABLES_ADMIN privileges.
See Section 7.1.9.1, “System Variable Privileges”.
Depending on whether the variable name and IF EXISTS clauses are present, the RESET PERSIST
statement has these forms:
• To remove all persisted variables from mysqld-auto.cnf, use RESET PERSIST without naming
any system variable:
RESET PERSIST;
You must have privileges for removing both dynamic and read-only system variables if mysqld-
auto.cnf contains both kinds of variables.
• To remove a specific persisted variable from mysqld-auto.cnf, name it in the statement:
RESET PERSIST system_var_name;
This includes plugin system variables, even if the plugin is not currently installed. If the variable is not
present in the file, an error occurs.
• To remove a specific persisted variable from mysqld-auto.cnf, but produce a warning rather than
an error if the variable is not present in the file, add an IF EXISTS clause to the previous syntax:
RESET PERSIST IF EXISTS system_var_name;
RESET PERSIST is not affected by the value of the persisted_globals_load system variable.
RESET PERSIST affects the contents of the Performance Schema persisted_variables table
because the table contents correspond to the contents of the mysqld-auto.cnf file. On the other
hand, because RESET PERSIST does not change variable values, it has no effect on the contents of
the Performance Schema variables_info table until the server is restarted.
For information about RESET statement variants that clear the state of other server operations, see
Section 15.7.8.6, “RESET Statement”.
15.7.8.8 RESTART Statement
RESTART
This statement stops and restarts the MySQL server. It requires the SHUTDOWN privilege.
One use for RESTART is when it is not possible or convenient to gain command-line access to the
MySQL server on the server host to restart it. For example, SET PERSIST_ONLY can be used at
runtime to make configuration changes to system variables that can be set only at server startup, but
the server must still be restarted for those changes to take effect. The RESTART statement provides a
way to do so from within client sessions, without requiring command-line access on the server host.
Note
After executing a RESTART statement, the client can expect the current
connection to be lost. If auto-reconnect is enabled, the connection is
reestablished after the server restarts. Otherwise, the connection must be
reestablished manually.
A successful RESTART operation requires mysqld to be running in an environment that has a
monitoring process available to detect a server shutdown performed for restart purposes:
• In the presence of a monitoring process, RESTART causes mysqld to terminate such that the
monitoring process can determine that it should start a new mysqld instance.
• If no monitoring process is present, RESTART fails with an error.
These platforms provide the necessary monitoring support for the RESTART statement:
• Windows, when mysqld is started as a Windows service or standalone. (mysqld forks, and one
process acts as a monitor to the other, which acts as the server.)
• Unix and Unix-like systems that use systemd or mysqld_safe to manage mysqld.
To configure a monitoring environment such that mysqld enables the RESTART statement:
1. Set the MYSQLD_PARENT_PID environment variable to the value of the process ID of the process
that starts mysqld, before starting mysqld.
2. When mysqld performs a shutdown due to use of the RESTART statement, it returns exit code 16.
3. When the monitoring process detects an exit code of 16, it starts mysqld again. Otherwise, it exits.
Here is a minimal example as implemented in the bash shell:
#!/bin/bash
export MYSQLD_PARENT_PID=$$
export MYSQLD_RESTART_EXIT=16
while true ; do
  bin/mysqld mysqld options here
  if [ $? -ne $MYSQLD_RESTART_EXIT ]; then
    break
  fi
done
On Windows, the forking used to implement RESTART makes determining the server process to attach
to for debugging more difficult. To alleviate this, starting the server with --gdb suppresses forking, in
addition to its other actions done to set up a debugging environment. In non-debug settings, --no-
monitor may be used for the sole purpose of suppressing forking the monitor process. For a server
started with either --gdb or --no-monitor, executing RESTART causes the server to simply exit
without restarting.
The Com_restart status variable tracks the number of RESTART statements. Because status
variables are initialized for each server startup and do not persist across restarts, Com_restart
normally has a value of zero, but can be nonzero if RESTART statements were executed but failed.
15.7.8.9 SHUTDOWN Statement
SHUTDOWN
This statement stops the MySQL server. It requires the SHUTDOWN privilege.
SHUTDOWN provides an SQL-level interface to the same functionality available using the mysqladmin
shutdown command. A successful SHUTDOWN sequence consists of checking the privileges, validating
the arguments, and sending an OK packet to the client. Then the server is shut down.
The Com_shutdown status variable tracks the number of SHUTDOWN statements. Because status
variables are initialized for each server startup and do not persist across restarts, Com_shutdown
normally has a value of zero, but can be nonzero if SHUTDOWN statements were executed but failed.
Another way to stop the server is to send it a SIGTERM signal, which can be done by root or the
account that owns the server process. SIGTERM enables server shutdown to be performed without
having to connect to the server. See Section 6.10, “Unix Signal Handling in MySQL”.